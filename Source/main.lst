CCS PCH C Compiler, Version 5.101, 43599               21-Mar-22 21:27

               Filename:   E:\Project\SPKT-KIT\Source\main.lst

               ROM used:   5968 bytes (5%)
                           Largest free fragment is 65536
               RAM used:   92 (2%) at main() level
                           113 (3%) worst case
               Stack used: 3 locations
               Stack size: 31

*
00000:  GOTO   15B2
.................... #include <main.h>
.................... #include <18F6722.h>
.................... //////////// Standard Header file for the PIC18F6722 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F6722
00004:  CLRF   FF7
00006:  ADDLW  18
00008:  MOVWF  FF6
0000A:  MOVLW  00
0000C:  ADDWFC FF7,F
0000E:  MOVLW  00
00010:  MOVWF  FF8
00012:  TBLRD*+
00014:  MOVF   FF5,W
00016:  RETURN 0
00018:  DATA C0,F9
0001A:  DATA A4,B0
0001C:  DATA 99,92
0001E:  DATA 82,F8
00020:  DATA 80,90
00022:  DATA 88,83
00024:  DATA C6,A1
00026:  DATA 86,8E
*
00196:  MOVF   x69,W
00198:  ANDLW  07
0019A:  MOVWF  00
0019C:  RRCF   x69,W
0019E:  MOVWF  01
001A0:  RRCF   01,F
001A2:  RRCF   01,F
001A4:  MOVLW  1F
001A6:  ANDWF  01,F
001A8:  MOVF   01,W
001AA:  ADDWF  x6B,W
001AC:  MOVWF  FE9
001AE:  MOVLW  00
001B0:  ADDWFC x6C,W
001B2:  MOVWF  FEA
001B4:  CLRF   01
001B6:  INCF   01,F
001B8:  INCF   00,F
001BA:  BRA    01BE
001BC:  RLCF   01,F
001BE:  DECFSZ 00,F
001C0:  BRA    01BC
001C2:  MOVF   x6A,F
001C4:  BZ    01CC
001C6:  MOVF   01,W
001C8:  IORWF  FEF,F
001CA:  BRA    01D2
001CC:  COMF   01,F
001CE:  MOVF   01,W
001D0:  ANDWF  FEF,F
001D2:  RETURN 0
001D4:  MOVF   x69,W
001D6:  ANDLW  07
001D8:  MOVWF  00
001DA:  RRCF   x69,W
001DC:  MOVWF  01
001DE:  RRCF   01,F
001E0:  RRCF   01,F
001E2:  MOVLW  1F
001E4:  ANDWF  01,F
001E6:  MOVF   01,W
001E8:  ADDWF  x6A,W
001EA:  MOVWF  FE9
001EC:  MOVLW  00
001EE:  ADDWFC x6B,W
001F0:  MOVWF  FEA
001F2:  MOVFF  FEF,01
001F6:  INCF   00,F
001F8:  BRA    01FC
001FA:  RRCF   01,F
001FC:  DECFSZ 00,F
001FE:  BRA    01FA
00200:  MOVLW  01
00202:  ANDWF  01,F
00204:  RETURN 0
*
002D4:  MOVF   x67,W
002D6:  CLRF   01
002D8:  SUBWF  x66,W
002DA:  BC    02E2
002DC:  MOVFF  66,00
002E0:  BRA    02FA
002E2:  CLRF   00
002E4:  MOVLW  08
002E6:  MOVWF  x68
002E8:  RLCF   x66,F
002EA:  RLCF   00,F
002EC:  MOVF   x67,W
002EE:  SUBWF  00,W
002F0:  BTFSC  FD8.0
002F2:  MOVWF  00
002F4:  RLCF   01,F
002F6:  DECFSZ x68,F
002F8:  BRA    02E8
002FA:  RETURN 0
.................... 
.................... #list
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #use delay(crystal=20000000)
*
000B0:  CLRF   FEA
000B2:  MOVLW  6A
000B4:  MOVWF  FE9
000B6:  MOVF   FEF,W
000B8:  BZ    00D4
000BA:  MOVLW  06
000BC:  MOVWF  01
000BE:  CLRF   00
000C0:  DECFSZ 00,F
000C2:  BRA    00C0
000C4:  DECFSZ 01,F
000C6:  BRA    00BE
000C8:  MOVLW  7B
000CA:  MOVWF  00
000CC:  DECFSZ 00,F
000CE:  BRA    00CC
000D0:  DECFSZ FEF,F
000D2:  BRA    00BA
000D4:  RETURN 0
.................... 
.................... 
.................... 
.................... #include <TV_PICKIT2_SHIFT_1.c>
.................... #ifndef    __TV_PICKIT2_SHIFT_1_C__
.................... #define    __TV_PICKIT2_SHIFT_1_C__
.................... #include<TV_PICKIT2_SHIFT_1.h>
.................... #ifndef    __TV_PICKIT2_SHIFT_1_H__
.................... #define    __TV_PICKIT2_SHIFT_1_H__
.................... 
.................... //#include    <18f6722.h>
.................... //#device     adc =10
.................... //#fuses      hs,PUT, NOWDT
.................... //#use        delay(clock=20M)
.................... //#use        i2c(I2C1)
.................... 
.................... 
.................... 
.................... #include    <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #define  soft_i2c_sda   pin_c4
.................... #define  soft_i2c_scl   pin_c3
.................... #DEFINE  BT0     PIN_b4
.................... #DEFINE  BT1     PIN_b5
.................... #DEFINE  BT2     PIN_b6
.................... #DEFINE  BT3     PIN_b7
.................... #DEFINE  ON      BT0 
.................... #DEFINE  UP      BT0  
.................... #DEFINE  ON1     BT0 
.................... #DEFINE  OFF     BT1
.................... #DEFINE  DW      BT1
.................... #DEFINE  OFF1    BT1
.................... #DEFINE  INV     BT2
.................... #DEFINE  ON2     BT2
.................... #DEFINE  CLR     BT2
.................... #DEFINE  MOD     BT3
.................... #DEFINE  STOP    BT3    
.................... #DEFINE  OFF2    BT3
.................... typedef enum 
.................... {
....................       OK  = 0,
....................       ERR = 1
.................... }result;
.................... CONST UNSIGNED CHAR MA7DOAN[16]= {0XC0,0XF9,0xA4,0XB0,0X99,0X92,0X82,0XF8,
.................... 0X80,0X90,0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E};  
.................... unsigned int8 LED_7DQ[8]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
.................... void xuat_32led_don_4byte(int8 b3,int8 b2,int8 b1,int8 b0);
.................... void xuat_32led_don_2word(int16 w1,int16 w0);
.................... void xuat_32led_don_1dw(int32 dwl);
.................... int1 inputcd (int16 pin);
.................... void xuat_4led_7doan_4so(int8 b3,int8 b2,int8 b1,int8 b0);
.................... void xuat_4led_7doan_giaima_xoa_so0(unsigned int16 tam);
.................... void xuat_8led_7doan_2byte(int8 data,int8 maquet);
.................... void hien_thi_8led_7doan_quet_all();
.................... void set_up_port_ic_chot();
.................... 
.................... #endif
.................... 
.................... void buzzer_on()
.................... {
....................       output_high(pin_f7);
.................... }
.................... void buzzer_off()
.................... {
....................       output_low(pin_f7);
*
0013A:  BCF    F97.7
0013C:  BCF    F8E.7
0013E:  GOTO   0180 (RETURN)
.................... }
.................... void xuat_32led_don_4byte(int8 b3,int8 b2,int8 b1,int8 b0)
.................... {
....................       spi_write2(b3);spi_write2(b2);
*
002FC:  MOVF   F66,W
002FE:  MOVFF  5D,F66
00302:  RRCF   F64,W
00304:  BNC   0302
00306:  MOVF   F66,W
00308:  MOVFF  5E,F66
0030C:  RRCF   F64,W
0030E:  BNC   030C
....................       spi_write2(b1);spi_write2(b0);
00310:  MOVF   F66,W
00312:  MOVFF  5F,F66
00316:  RRCF   F64,W
00318:  BNC   0316
0031A:  MOVF   F66,W
0031C:  MOVFF  60,F66
00320:  RRCF   F64,W
00322:  BNC   0320
....................       output_high(pin_d5); output_low(pin_d5);
00324:  BCF    F95.5
00326:  BSF    F8C.5
00328:  BCF    F95.5
0032A:  BCF    F8C.5
0032C:  RETURN 0
.................... }
.................... void xuat_32led_don_2word(int16 w1,int16 w0)
.................... {
....................       spi_write2(w1>>8);spi_write2(w1);
*
006D2:  MOVFF  6B,6F
006D6:  CLRF   x70
006D8:  MOVF   F66,W
006DA:  MOVFF  6B,F66
006DE:  RRCF   F64,W
006E0:  BNC   06DE
006E2:  MOVF   F66,W
006E4:  MOVFF  6A,F66
006E8:  RRCF   F64,W
006EA:  BNC   06E8
....................       spi_write2(w0>>8);spi_write2(w0);
006EC:  MOVFF  6D,6F
006F0:  CLRF   x70
006F2:  MOVF   F66,W
006F4:  MOVFF  6D,F66
006F8:  RRCF   F64,W
006FA:  BNC   06F8
006FC:  MOVF   F66,W
006FE:  MOVFF  6C,F66
00702:  RRCF   F64,W
00704:  BNC   0702
....................       output_high(pin_d5); output_low(pin_d5);
00706:  BCF    F95.5
00708:  BSF    F8C.5
0070A:  BCF    F95.5
0070C:  BCF    F8C.5
0070E:  RETURN 0
.................... }
.................... void  xuat_32led_don_1dw(int32 dwl)
.................... {
....................       spi_write2(dwl>>24);spi_write2(dwl>>16);
*
0005A:  MOVFF  65,67
0005E:  CLRF   x68
00060:  CLRF   x69
00062:  CLRF   x6A
00064:  MOVF   F66,W
00066:  MOVFF  65,F66
0006A:  RRCF   F64,W
0006C:  BNC   006A
0006E:  MOVFF  64,67
00072:  MOVFF  65,68
00076:  CLRF   x69
00078:  CLRF   x6A
0007A:  MOVF   F66,W
0007C:  MOVFF  64,F66
00080:  RRCF   F64,W
00082:  BNC   0080
....................       spi_write2(dwl>>8);spi_write2(dwl);
00084:  MOVFF  63,67
00088:  MOVFF  64,68
0008C:  MOVFF  65,69
00090:  CLRF   x6A
00092:  MOVF   F66,W
00094:  MOVFF  63,F66
00098:  RRCF   F64,W
0009A:  BNC   0098
0009C:  MOVF   F66,W
0009E:  MOVFF  62,F66
000A2:  RRCF   F64,W
000A4:  BNC   00A2
....................       output_high(pin_d5); output_low(pin_d5);
000A6:  BCF    F95.5
000A8:  BSF    F8C.5
000AA:  BCF    F95.5
000AC:  BCF    F8C.5
000AE:  RETURN 0
.................... }
.................... 
.................... int1 inputcd(int16 pin)
.................... {
....................       int8 n;
....................       static int16 oldpin=0xffff;
....................       static int1 tt=0;
....................       static int1 dem=0;
....................       if((input(pin)==0)&&(dem==0))
*
00206:  MOVFF  66,69
0020A:  MOVLW  01
0020C:  MOVWF  x6A
0020E:  MOVLW  0F
00210:  MOVWF  x6C
00212:  MOVLW  92
00214:  MOVWF  x6B
00216:  RCALL  0196
00218:  MOVFF  66,69
0021C:  MOVLW  0F
0021E:  MOVWF  x6B
00220:  MOVLW  80
00222:  MOVWF  x6A
00224:  RCALL  01D4
00226:  BTFSC  01.0
00228:  BRA    0260
0022A:  BTFSC  0E.1
0022C:  BRA    0260
....................        {
....................          if(tt==0) {oldpin = pin;tt=1;}
0022E:  BTFSC  0E.0
00230:  BRA    023C
00232:  MOVFF  67,0D
00236:  MOVFF  66,0C
0023A:  BSF    0E.0
....................          if(pin==oldpin) 
0023C:  MOVF   0C,W
0023E:  SUBWF  x66,W
00240:  BNZ   025E
00242:  MOVF   0D,W
00244:  SUBWF  x67,W
00246:  BNZ   025E
....................           {
....................            for(n=0;n<5;n++)hien_thi_8led_7doan_quet_all();
00248:  CLRF   x68
0024A:  MOVF   x68,W
0024C:  SUBLW  04
0024E:  BNC   0256
00250:  RCALL  00D6
00252:  INCF   x68,F
00254:  BRA    024A
....................            dem=1;
00256:  BSF    0E.1
....................            return 0;
00258:  MOVLW  00
0025A:  MOVWF  01
0025C:  BRA    02D2
....................           }
....................       }
0025E:  BRA    02CE
....................       else if(input(pin)&&dem)
00260:  MOVFF  66,69
00264:  MOVLW  01
00266:  MOVWF  x6A
00268:  MOVLW  0F
0026A:  MOVWF  x6C
0026C:  MOVLW  92
0026E:  MOVWF  x6B
00270:  RCALL  0196
00272:  MOVFF  66,69
00276:  MOVLW  0F
00278:  MOVWF  x6B
0027A:  MOVLW  80
0027C:  MOVWF  x6A
0027E:  RCALL  01D4
00280:  BTFSS  01.0
00282:  BRA    02CE
00284:  BTFSS  0E.1
00286:  BRA    02CE
....................       {
....................           if(pin==oldpin)
00288:  MOVF   0C,W
0028A:  SUBWF  x66,W
0028C:  BNZ   02CE
0028E:  MOVF   0D,W
00290:  SUBWF  x67,W
00292:  BNZ   02CE
....................           {   
....................               for(n=0;n<5;n++)hien_thi_8led_7doan_quet_all();
00294:  CLRF   x68
00296:  MOVF   x68,W
00298:  SUBLW  04
0029A:  BNC   02A2
0029C:  RCALL  00D6
0029E:  INCF   x68,F
002A0:  BRA    0296
....................               if(input(pin))
002A2:  MOVFF  66,69
002A6:  MOVLW  01
002A8:  MOVWF  x6A
002AA:  MOVLW  0F
002AC:  MOVWF  x6C
002AE:  MOVLW  92
002B0:  MOVWF  x6B
002B2:  RCALL  0196
002B4:  MOVFF  66,69
002B8:  MOVLW  0F
002BA:  MOVWF  x6B
002BC:  MOVLW  80
002BE:  MOVWF  x6A
002C0:  RCALL  01D4
002C2:  BTFSS  01.0
002C4:  BRA    02CE
....................               {
....................                  tt=0; 
002C6:  BCF    0E.0
....................                  dem=0;
002C8:  BCF    0E.1
....................                  oldpin=0xffff;
002CA:  SETF   0D
002CC:  SETF   0C
....................               }
....................           }
....................       }
....................       return 1; 
002CE:  MOVLW  01
002D0:  MOVWF  01
002D2:  RETURN 0
.................... }
.................... 
.................... void xuat_4led_7doan_4so(int8 b3,int8 b2,int8 b1,int8 b0)
.................... {
....................       spi_write2(b0);spi_write2(b1);
*
00028:  MOVF   F66,W
0002A:  MOVFF  6C,F66
0002E:  RRCF   F64,W
00030:  BNC   002E
00032:  MOVF   F66,W
00034:  MOVFF  6B,F66
00038:  RRCF   F64,W
0003A:  BNC   0038
....................       spi_write2(b2);spi_write2(b3);
0003C:  MOVF   F66,W
0003E:  MOVFF  6A,F66
00042:  RRCF   F64,W
00044:  BNC   0042
00046:  MOVF   F66,W
00048:  MOVFF  69,F66
0004C:  RRCF   F64,W
0004E:  BNC   004C
....................       output_high(pin_d7); output_low(pin_d7);
00050:  BCF    F95.7
00052:  BSF    F8C.7
00054:  BCF    F95.7
00056:  BCF    F8C.7
00058:  RETURN 0
.................... }
.................... 
.................... void xuat_4led_7doan_giaima_xoa_so0(unsigned int16 tam)
.................... {
....................       unsigned int8 ht[4]={0xff,0xff,0xff,0xff},i=0;
....................       do
....................       {
....................           ht[i]= ma7doan[tam%10];
....................           tam/=10;i++;
....................       }
....................       while(tam);
....................       xuat_4led_7doan_4so(ht[3],ht[2],ht[1],ht[0]);
.................... }
.................... 
.................... void hien_thi_8led_7doan_quet_all()
.................... {
....................       unsigned int8 n;
....................       for(n=0;n<8;n++)
*
000D6:  CLRF   x69
000D8:  MOVF   x69,W
000DA:  SUBLW  07
000DC:  BNC   0138
....................       {       
....................             spi_write2(0x01<<n);
000DE:  MOVLW  01
000E0:  MOVWF  x6A
000E2:  MOVF   x69,W
000E4:  MOVWF  01
000E6:  BZ    00F0
000E8:  BCF    FD8.0
000EA:  RLCF   x6A,F
000EC:  DECFSZ 01,F
000EE:  BRA    00E8
000F0:  MOVF   F66,W
000F2:  MOVFF  6A,F66
000F6:  RRCF   F64,W
000F8:  BNC   00F6
....................             spi_write2(LED_7DQ[n]);
000FA:  CLRF   03
000FC:  MOVF   x69,W
000FE:  ADDLW  04
00100:  MOVWF  FE9
00102:  MOVLW  00
00104:  ADDWFC 03,W
00106:  MOVWF  FEA
00108:  MOVFF  FEF,6A
0010C:  MOVF   F66,W
0010E:  MOVFF  6A,F66
00112:  RRCF   F64,W
00114:  BNC   0112
....................             output_high(pin_d1); output_low(pin_d1);
00116:  BCF    F95.1
00118:  BSF    F8C.1
0011A:  BCF    F95.1
0011C:  BCF    F8C.1
....................             delay_ms(1);
0011E:  MOVLW  01
00120:  MOVWF  x6A
00122:  RCALL  00B0
....................             spi_write2(0xff);
00124:  MOVF   F66,W
00126:  SETF   F66
00128:  RRCF   F64,W
0012A:  BNC   0128
....................             output_high(pin_d1); output_low(pin_d1);
0012C:  BCF    F95.1
0012E:  BSF    F8C.1
00130:  BCF    F95.1
00132:  BCF    F8C.1
00134:  INCF   x69,F
00136:  BRA    00D8
....................       }
00138:  RETURN 0
.................... }
.................... void triac_2_on()
.................... {
....................       output_high(Pin_f6);
.................... }
.................... void triac_2_off()
.................... {
....................       output_low(Pin_f6);
*
00142:  BCF    F97.6
00144:  BCF    F8E.6
00146:  GOTO   0182 (RETURN)
.................... }
.................... void set_up_port_ic_chot()
.................... {
....................       set_tris_a(0xff);
0014A:  MOVLW  FF
0014C:  MOVWF  F92
....................       set_tris_d(0x04);
0014E:  MOVLW  04
00150:  MOVWF  F95
....................       set_tris_e(0);
00152:  MOVLW  00
00154:  MOVWF  F96
....................       set_tris_f(0);
00156:  MOVWF  F97
....................       set_tris_g(0);
00158:  MOVWF  F98
....................       port_b_pullups(0xFF);
0015A:  BCF    FF1.7
....................       output_g(0);
0015C:  CLRF   F98
0015E:  CLRF   F8F
....................       xuat_4led_7doan_4so(0xff,0xff,0xff,0xff);   // tat 4 led 7 doan
00160:  SETF   x69
00162:  SETF   x6A
00164:  SETF   x6B
00166:  SETF   x6C
00168:  RCALL  0028
....................       xuat_32led_don_1dw(0);                      // tat led don
0016A:  CLRF   x65
0016C:  CLRF   x64
0016E:  CLRF   x63
00170:  CLRF   x62
00172:  RCALL  005A
....................       output_high(pin_g0);
00174:  BCF    F98.0
00176:  BSF    F8F.0
....................       set_tris_c(0xff);
00178:  MOVLW  FF
0017A:  MOVWF  F94
....................       hien_thi_8led_7doan_quet_all();
0017C:  RCALL  00D6
....................       buzzer_off(); 
0017E:  BRA    013A
....................       triac_2_off();
00180:  BRA    0142
.................... #ifdef   __TV_PICKIT2_SHIFT_LCD_H__
00182:  GOTO   1698 (RETURN)
....................      setup_lcd(); 
.................... #endif
.................... }
.................... //////////////////// Soft I2C ///////////////////////////
.................... void soft_i2c_clk()
.................... {   
....................     output_high(soft_i2c_scl);
....................     DELAY_us(1);  
....................     output_low(soft_i2c_scl);
.................... }
.................... void soft_i2c_start()
.................... {
....................       output_high(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       delay_us(1);
....................       output_low(soft_i2c_sda);
....................       delay_us(1);
....................       output_low(soft_i2c_scl);      
.................... }
.................... void soft_i2c_stop()
.................... {
....................       output_low(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       delay_us(1);
....................       output_high(soft_i2c_sda);
.................... }
.................... void soft_i2c_write(unsigned int8 b)
.................... {
....................       unsigned int8 m;
....................       for(m=0x80;m>0;m>>=1)
....................       {
....................             output_bit( soft_i2c_sda,b&m);
....................             soft_i2c_clk();
....................       }
....................       soft_i2c_clk();
.................... }
.................... 
.................... unsigned int8 soft_i2c_read(int1 ack)
.................... { 
....................       unsigned int8 n,nhan=0;
....................       output_float(soft_i2c_sda);
....................       for(n=0x80;n>0;n>>=1)
....................       {      
....................             output_high(soft_i2c_scl);  
....................             delay_us(1);
....................             if(input(soft_i2c_sda))nhan=nhan|n;
....................             output_low(soft_i2c_scl);   
....................       }
....................       if(ack)  output_low(soft_i2c_sda);
....................       else     output_high(soft_i2c_sda); 
....................       soft_i2c_clk();
....................       output_high(soft_i2c_sda); 
....................       return nhan;
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... #include <TV_PICKIT2_SHIFT_32LED_DON.c>
.................... unsigned int32    y=0,yp_chay=1,yt_chay=0x80000000,y_codinh=0;
.................... unsigned int16 zt,zt_chay_t=0x8000,zt_chay_p=1,zt_codinh=0;
.................... unsigned int16 zp,zp_chay_t=0x8000,zp_chay_p=1,zp_codinh=0;
.................... 
.................... unsigned int16 tgdlay=0;
.................... unsigned int8 dem_led=0; 
.................... signed i32=32,j32=0,ttct_td=1,i16=16,j16=0;
.................... 
.................... unsigned int32    za=1,ya=1,xa=0xfffffffe,zb=0x80000000,yb=0x80000000,xb=0x7fffffff;   
.................... signed ia=1,ja=1;  
.................... void reset_toan_bo_bien()
.................... { 
....................       ttct_td++;     //chuyen chuong trinh cho tu dong
....................       y=0;      yp_chay=1;      yt_chay=0x80000000;      y_codinh=0;
....................       zt_chay_t=0x8000;    zt_chay_p=1;   zt_codinh=0;
....................       zp_chay_t=0x8000;    zp_chay_p=1;   zp_codinh=0;
....................       zt=zp=0;
....................       i32=32;j32=0;i16=16,j16=0;
....................       dem_led=0;
....................       
....................       za=1;    ya=1;    xa=0xfffffffe;     ia=1;    ja=1;
....................      zb=0x80000000;    yb=0x80000000;    xb=0x7fffffff;
.................... } 
.................... 
.................... void tang_dem_led_delay_1(unsigned int8 dl)
.................... { 
....................       unsigned int8 i;
....................       for (i=0; i<dl;i++)
....................       hien_thi_8led_7doan_quet_all();
....................       dem_led++;
.................... } 
.................... 
.................... void tang_dem_led_delay_0(unsigned int8 dl)
.................... { 
....................       if (dl>0)      delay_ms(dl); 
....................       dem_led++;
.................... } 
.................... 
.................... void delay_chon(unsigned int8 dl,chondelay)
.................... {    
....................    if (!chondelay)   tang_dem_led_delay_0(dl);
....................    else              tang_dem_led_delay_1(dl);
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang don  phai sang trai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void diem_sang_dich_trai_mat_dan_32led(unsigned int8 dl,chondelay)
.................... {       
....................    if(ia<33)
....................    {
....................       if(ja>0)
....................       {
....................          zb = (zb << 1);
....................          y = xb|zb;        
....................          xuat_32led_don_1dw(y);
....................          delay_chon(dl,chondelay);
....................          ja--;
....................       }
....................       else 
....................       {
....................          ia++;
....................          ja=ia;      
....................          yb = yb>>1;
....................          xb = xb>>1;
....................          zb = yb;
....................       }
....................    }
....................    else reset_toan_bo_bien();
.................... }  
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang don  trai sang phai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void diem_sang_dich_phai_mat_dan_32led(unsigned int8 dl,chondelay)
.................... {       
....................    if(ia<33)
....................    {
....................       if(ja>0)
....................       {
....................          za = (za >> 1);
....................          y = xa|za;        
....................          xuat_32led_don_1dw(y);
....................          delay_chon(dl,chondelay);
....................          ja--;
....................       }
....................       else 
....................       {
....................          ia++;
....................          ja=ia;      
....................          ya = ya<<1;
....................          xa = xa <<1;
....................          za = ya;
....................       }
....................    }
....................    else reset_toan_bo_bien();
.................... }  
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: chop tat 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void dao_dl_32bit_va_xuat()
.................... {
....................    y=~y;
....................    xuat_32led_don_1dw(y); 
.................... }
.................... void sang_tat_32led(unsigned int8 dl,chondelay)
.................... {        
....................       if (tgdlay==1)          xuat_32led_don_1dw(y); 
....................       else if (tgdlay==50)    dao_dl_32bit_va_xuat();
....................       else if (tgdlay==100)   dao_dl_32bit_va_xuat();          
....................       else if (tgdlay==150)   dao_dl_32bit_va_xuat();                 
....................       else if (tgdlay==200)  
....................       {
....................          ttct_td++;   y=0;        tgdlay=0;
....................       }
....................       tgdlay++;
....................       delay_chon(dl,chondelay);
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang dan roi tat dan tu ngoai vao
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_tat_dan_ngoai_vao_32led(unsigned int8 dl,chondelay)
.................... {  
....................    if (dem_led<16)
....................    {  
....................       xuat_32led_don_2word(zp,zt);        
....................       zp= (zp<<1)+1; 
....................       zt= (zt>>1)+0x8000;
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<32)
....................    {  
....................       xuat_32led_don_2word(zp,zt);
....................       zp= (zp<<1); 
....................       zt= (zt>>1);
....................       delay_chon(dl,chondelay);
....................    }
....................    else reset_toan_bo_bien();
.................... 
.................... }   
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang dan roi tat dan tu trong ra
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_tat_dan_trong_ra_32led(unsigned int8 dl,chondelay)
.................... {  
....................    if (dem_led<16)
....................    {   
....................       xuat_32led_don_2word(zp,zt); 
....................       zp= (zp>>1)+0x8000; 
....................       zt= (zt<<1)+1;
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<32)
....................    {  
....................       xuat_32led_don_2word(zp,zt);
....................       zp= (zp>>1); 
....................       zt= (zt<<1);
....................       delay_chon(dl,chondelay);
....................     }
....................    else reset_toan_bo_bien();
....................         
.................... }   
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: 2nhom 16 led sang dan roi tat dan tu phai sang trai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_tat_dan_phai_sang_trai_2x16led(unsigned int8 dl,chondelay)
.................... {  
....................    if (dem_led<16)
....................    {   
....................       xuat_32led_don_2word(zp,zp);
....................       zp= (zp>>1)+0x8000;
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<32)
....................    {  
....................       xuat_32led_don_2word(zp,zp);
....................       zp= (zp>>1);
....................       delay_chon(dl,chondelay);
....................     }
....................    else reset_toan_bo_bien();
....................       
.................... }   
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: 2nhom 16 led sang dan roi tat dan tu trai sang phai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_tat_dan_trai_sang_phai_2x16led(unsigned int8 dl,chondelay)
.................... {  
....................    if (dem_led<16)
....................    {   
....................       xuat_32led_don_2word(zt,zt);  
....................       zt= (zt<<1)+1;
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<32)
....................    {  
....................       xuat_32led_don_2word(zt,zt);
....................       zt= (zt<<1);
....................       delay_chon(dl,chondelay);
....................     }
....................    else reset_toan_bo_bien();
....................         
.................... }   
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang dan roi tat dan tu phai sang trai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_tat_dan_pst_32led(unsigned int8 dl,chondelay)
.................... {        
....................    if (dem_led<32)
....................    {  
....................       xuat_32led_don_1dw(y);
....................       y= (y<<1)+1;
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<64)
....................    {  
....................       xuat_32led_don_1dw(y);   
....................       y= (y<<1); 
....................       delay_chon(dl,chondelay);
....................    } 
....................    else reset_toan_bo_bien();
.................... 
.................... }    
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang dan roi tat dan tu trai sang phai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_tat_dan_tsp_32led(unsigned int8 dl,chondelay)
.................... {           
....................       if (dem_led<32)
....................       {  
....................          xuat_32led_don_1dw(y);
....................          y= (y>>1)+0x80000000; 
....................          delay_chon(dl,chondelay);      
....................       }
....................       else
....................       if (dem_led<64)
....................       {  
....................          xuat_32led_don_1dw(y); 
....................          y= (y>>1);
....................          delay_chon(dl,chondelay);
....................       } 
....................       else reset_toan_bo_bien();
....................     
.................... }         
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: diem sang di chueyn tu phai sang trai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx OK
.................... void diem_sang_di_chuyen_pst_32led(unsigned int8 dl,chondelay)
.................... {        
....................    if (dem_led==0)
....................    {  
....................       y=1;
....................       xuat_32led_don_1dw(y);
....................       y= (y<<1);
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<33)
....................    {  
....................       xuat_32led_don_1dw(y);   
....................       y= (y<<1); 
....................       delay_chon(dl,chondelay);
....................    } 
....................    else  reset_toan_bo_bien();
.................... }    
.................... 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: diem sang di chueyn tu trai sang phai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx OK
.................... void diem_sang_di_chuyen_tsp_32led(unsigned int8 dl,chondelay)
.................... {        
....................    if (dem_led==0)
....................    {  
....................       y=0x80000000;
....................       xuat_32led_don_1dw(y);
....................       y= (y>>1);
....................       delay_chon(dl,chondelay);
....................    }
....................    else  if (dem_led<33)
....................    {  
....................       xuat_32led_don_1dw(y);   
....................       y= (y>>1); 
....................       delay_chon(dl,chondelay);
....................    } 
....................    else reset_toan_bo_bien();
.................... 
.................... } 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang don  phai sang trai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
.................... void sang_don_pst_32led(unsigned int8 dl,chondelay)
.................... {       
....................    if(i32>0)
....................    {
....................       if(j32<i32)
....................       {
....................          y = y_codinh|yp_chay;
....................          xuat_32led_don_1dw(y);
....................          delay_chon(dl,chondelay);       
....................          yp_chay = yp_chay <<1;
....................          j32++;
....................       }
....................       if (j32==i32) 
....................       {
....................          i32--;
....................          j32=0;         
....................          y_codinh=y;
....................          yp_chay = 1;
....................       }
....................    }
....................    else reset_toan_bo_bien();
.................... }   
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang don  phai sang trai
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_don_tsp_32led(unsigned int8 dl,chondelay)
.................... {       
....................    if(i32>0)
....................    {
....................       if(j32<i32)
....................       {
....................          y = y_codinh|yt_chay;
....................          xuat_32led_don_1dw(y);
....................          delay_chon(dl,chondelay);
....................          yt_chay = yt_chay >>1;
....................          j32++;
....................       }
....................       if (j32==i32) 
....................       {
....................          i32--;
....................          j32=0;         
....................          y_codinh=y;
....................          yt_chay = 0x80000000;
....................       }
....................    }
....................    else reset_toan_bo_bien();
.................... 
.................... }  
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang don  tu ngoai vao
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... void sang_don_tnt_32led(unsigned int8 dl,chondelay)
.................... {       
....................    if(i16>0)
....................    {
....................       if(j16<i16)
....................       {
....................          zp = zp_codinh|zp_chay_p;
....................          zt = zt_codinh|zt_chay_t;
....................          xuat_32led_don_2word(zt,zp);
....................          delay_chon(dl,chondelay);
.................... 
....................          zp_chay_p = zp_chay_p <<1;         
....................          zt_chay_t = zt_chay_t >>1;
....................          j16++;
....................       }
....................       if (j16==i16) 
....................       {
....................          i16--;
....................          j16=0;         
....................          zt_codinh=zt;  zp_codinh=zp;         
....................          zp_chay_p = 1;   zt_chay_t = 0x8000;
....................       }
....................    }
....................    else reset_toan_bo_bien();
.................... 
.................... }   
.................... 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... //32 led: sang don  tu ngoai vao
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx OK
.................... void sang_don_ttr_32led(unsigned int8 dl,chondelay)
.................... {       
....................    if(i16>0)
....................    {
....................       if(j16<i16)
....................       {
....................          zp = zp_codinh|zp_chay_t;
....................          zt = zt_codinh|zt_chay_p;
....................          xuat_32led_don_2word(zt,zp);
....................          delay_chon(dl,chondelay);
....................          zp_chay_t = zp_chay_t >>1;         
....................          zt_chay_p = zt_chay_p <<1;
....................          j16++;
....................       }
....................       if (j16==i16) 
....................       {
....................          i16--;
....................          j16=0;         
....................          zt_codinh=zt;  
....................          zp_codinh=zp;
....................          zp_chay_t = 0x8000;   zt_chay_p = 1;
....................       }
....................    }
....................    else reset_toan_bo_bien();
.................... }   
.................... 
.................... 
.................... 
.................... 
.................... #USE        SPI(SPI2)
.................... 
.................... uintmax_t systemTick = 0;
.................... signed int8 trangThaiLed = 0; // bien trang thai
.................... unsigned int1 ledRun = 0;
.................... unsigned int1 trangThaiDem;
.................... unsigned int8 bienDem; 
.................... unsigned int8 hangDonVi;
.................... unsigned int8 hangChuc;
.................... 
.................... 
.................... void hardwareInit()
.................... {
....................    setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00186:  BCF    FD1.0
00188:  MOVLW  A8
0018A:  MOVWF  FD5
....................    set_rtcc(0);       
0018C:  CLRF   FD7
0018E:  CLRF   FD6
00190:  NOP   
00192:  GOTO   169C (RETURN)
.................... }
.................... 
.................... 
.................... void b301_8led_chop_tat(unsigned int32 dl)                 
.................... {   
....................    bienDem = get_rtcc();
*
0032E:  MOVF   FD6,W
00330:  MOVWF  56
....................     if (inputcd(INV) == 0)
00332:  MOVLW  7C
00334:  MOVWF  x67
00336:  MOVLW  0E
00338:  MOVWF  x66
0033A:  RCALL  0206
0033C:  MOVF   01,F
0033E:  BNZ   0350
....................       {
....................          trangThaiDem = ~trangThaiDem;
00340:  BTG    0E.3
....................          if(trangThaiDem)
00342:  BTFSS  0E.3
00344:  BRA    034A
....................          {
....................             setup_timer_0(RTCC_OFF);
00346:  CLRF   FD5
....................          }else
00348:  BRA    0350
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
0034A:  BCF    FD1.0
0034C:  MOVLW  A8
0034E:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................     if(bienDem>24)
00350:  MOVF   56,W
00352:  SUBLW  18
00354:  BC    035E
....................    {
....................      bienDem = 0; 
00356:  CLRF   56
....................      set_rtcc(0);
00358:  CLRF   FD7
0035A:  CLRF   FD6
0035C:  NOP   
....................    }
....................    hangDonVi = bienDem%10;
0035E:  MOVFF  56,66
00362:  MOVLW  0A
00364:  MOVWF  x67
00366:  RCALL  02D4
00368:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0036C:  MOVFF  56,66
00370:  MOVLW  0A
00372:  MOVWF  x67
00374:  RCALL  02D4
00376:  MOVFF  01,58
....................   xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0037A:  CLRF   03
0037C:  MOVF   55,W
0037E:  MOVWF  00
00380:  BTFSC  FE8.7
00382:  DECF   03,F
00384:  RCALL  0004
00386:  MOVWF  5D
00388:  CLRF   03
0038A:  MOVF   58,W
0038C:  RCALL  0004
0038E:  MOVWF  5E
00390:  CLRF   03
00392:  MOVF   57,W
00394:  RCALL  0004
00396:  MOVWF  5F
00398:  MOVFF  5D,69
0039C:  MOVLW  3F
0039E:  MOVWF  x6A
003A0:  MOVFF  5E,6B
003A4:  MOVFF  5F,6C
003A8:  RCALL  0028
....................    xuat_32led_don_4byte(0,0,0,0);     delay_ms(dl);    
003AA:  CLRF   5D
003AC:  CLRF   5E
003AE:  CLRF   5F
003B0:  CLRF   x60
003B2:  RCALL  02FC
003B4:  MOVFF  5A,5D
003B8:  INCF   5D,F
003BA:  DECF   5D,F
003BC:  BTFSC  FD8.2
003BE:  BRA    03C6
003C0:  SETF   x6A
003C2:  RCALL  00B0
003C4:  BRA    03BA
003C6:  MOVFF  59,6A
003CA:  RCALL  00B0
....................     bienDem = get_rtcc();
003CC:  MOVF   FD6,W
003CE:  MOVWF  56
....................      if (inputcd(INV) == 0)
003D0:  MOVLW  7C
003D2:  MOVWF  x67
003D4:  MOVLW  0E
003D6:  MOVWF  x66
003D8:  RCALL  0206
003DA:  MOVF   01,F
003DC:  BNZ   03EE
....................       {
....................          trangThaiDem = ~trangThaiDem;
003DE:  BTG    0E.3
....................          if(trangThaiDem)
003E0:  BTFSS  0E.3
003E2:  BRA    03E8
....................          {
....................             setup_timer_0(RTCC_OFF);
003E4:  CLRF   FD5
....................          }else
003E6:  BRA    03EE
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
003E8:  BCF    FD1.0
003EA:  MOVLW  A8
003EC:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
003EE:  MOVF   56,W
003F0:  SUBLW  18
003F2:  BC    03FC
....................    {
....................      bienDem = 0; 
003F4:  CLRF   56
....................      set_rtcc(0);
003F6:  CLRF   FD7
003F8:  CLRF   FD6
003FA:  NOP   
....................    }
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
003FC:  CLRF   03
003FE:  MOVF   55,W
00400:  MOVWF  00
00402:  BTFSC  FE8.7
00404:  DECF   03,F
00406:  RCALL  0004
00408:  MOVWF  5D
0040A:  CLRF   03
0040C:  MOVF   58,W
0040E:  RCALL  0004
00410:  MOVWF  5E
00412:  CLRF   03
00414:  MOVF   57,W
00416:  RCALL  0004
00418:  MOVWF  5F
0041A:  MOVFF  5D,69
0041E:  MOVLW  3F
00420:  MOVWF  x6A
00422:  MOVFF  5E,6B
00426:  MOVFF  5F,6C
0042A:  RCALL  0028
....................    xuat_32led_don_4byte(0,0,0,0xff);  delay_ms(dl);         
0042C:  CLRF   5D
0042E:  CLRF   5E
00430:  CLRF   5F
00432:  SETF   x60
00434:  RCALL  02FC
00436:  MOVFF  5A,5D
0043A:  INCF   5D,F
0043C:  DECF   5D,F
0043E:  BTFSC  FD8.2
00440:  BRA    0448
00442:  SETF   x6A
00444:  RCALL  00B0
00446:  BRA    043C
00448:  MOVFF  59,6A
0044C:  RCALL  00B0
0044E:  GOTO   1226 (RETURN)
.................... } 
.................... void b302_16led_chop_tat(unsigned int32 dl)                 
.................... {        
....................  bienDem = get_rtcc();
00452:  MOVF   FD6,W
00454:  MOVWF  56
....................   if (inputcd(INV) == 0)
00456:  MOVLW  7C
00458:  MOVWF  x67
0045A:  MOVLW  0E
0045C:  MOVWF  x66
0045E:  RCALL  0206
00460:  MOVF   01,F
00462:  BNZ   0474
....................       {
....................          trangThaiDem = ~trangThaiDem;
00464:  BTG    0E.3
....................          if(trangThaiDem)
00466:  BTFSS  0E.3
00468:  BRA    046E
....................          {
....................             setup_timer_0(RTCC_OFF);
0046A:  CLRF   FD5
....................          }else
0046C:  BRA    0474
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
0046E:  BCF    FD1.0
00470:  MOVLW  A8
00472:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................   if(bienDem>24)
00474:  MOVF   56,W
00476:  SUBLW  18
00478:  BC    0482
....................    {
....................      bienDem = 0; 
0047A:  CLRF   56
....................      set_rtcc(0);
0047C:  CLRF   FD7
0047E:  CLRF   FD6
00480:  NOP   
....................    }
....................  hangDonVi = bienDem%10;
00482:  MOVFF  56,66
00486:  MOVLW  0A
00488:  MOVWF  x67
0048A:  RCALL  02D4
0048C:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00490:  MOVFF  56,66
00494:  MOVLW  0A
00496:  MOVWF  x67
00498:  RCALL  02D4
0049A:  MOVFF  01,58
....................   xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0049E:  CLRF   03
004A0:  MOVF   55,W
004A2:  MOVWF  00
004A4:  BTFSC  FE8.7
004A6:  DECF   03,F
004A8:  RCALL  0004
004AA:  MOVWF  5D
004AC:  CLRF   03
004AE:  MOVF   58,W
004B0:  RCALL  0004
004B2:  MOVWF  5E
004B4:  CLRF   03
004B6:  MOVF   57,W
004B8:  RCALL  0004
004BA:  MOVWF  5F
004BC:  MOVFF  5D,69
004C0:  MOVLW  3F
004C2:  MOVWF  x6A
004C4:  MOVFF  5E,6B
004C8:  MOVFF  5F,6C
004CC:  RCALL  0028
....................    xuat_32led_don_4byte(0,0,0,0);     delay_ms(dl);  
004CE:  CLRF   5D
004D0:  CLRF   5E
004D2:  CLRF   5F
004D4:  CLRF   x60
004D6:  RCALL  02FC
004D8:  MOVFF  5A,5D
004DC:  INCF   5D,F
004DE:  DECF   5D,F
004E0:  BTFSC  FD8.2
004E2:  BRA    04EA
004E4:  SETF   x6A
004E6:  RCALL  00B0
004E8:  BRA    04DE
004EA:  MOVFF  59,6A
004EE:  RCALL  00B0
....................     bienDem = get_rtcc();
004F0:  MOVF   FD6,W
004F2:  MOVWF  56
....................      if (inputcd(INV) == 0)
004F4:  MOVLW  7C
004F6:  MOVWF  x67
004F8:  MOVLW  0E
004FA:  MOVWF  x66
004FC:  RCALL  0206
004FE:  MOVF   01,F
00500:  BNZ   0512
....................       {
....................          trangThaiDem = ~trangThaiDem;
00502:  BTG    0E.3
....................          if(trangThaiDem)
00504:  BTFSS  0E.3
00506:  BRA    050C
....................          {
....................             setup_timer_0(RTCC_OFF);
00508:  CLRF   FD5
....................          }else
0050A:  BRA    0512
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
0050C:  BCF    FD1.0
0050E:  MOVLW  A8
00510:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00512:  MOVF   56,W
00514:  SUBLW  18
00516:  BC    0520
....................    {
....................      bienDem = 0; 
00518:  CLRF   56
....................      set_rtcc(0);
0051A:  CLRF   FD7
0051C:  CLRF   FD6
0051E:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00520:  MOVFF  56,66
00524:  MOVLW  0A
00526:  MOVWF  x67
00528:  RCALL  02D4
0052A:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0052E:  MOVFF  56,66
00532:  MOVLW  0A
00534:  MOVWF  x67
00536:  RCALL  02D4
00538:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0053C:  CLRF   03
0053E:  MOVF   55,W
00540:  MOVWF  00
00542:  BTFSC  FE8.7
00544:  DECF   03,F
00546:  RCALL  0004
00548:  MOVWF  5D
0054A:  CLRF   03
0054C:  MOVF   58,W
0054E:  RCALL  0004
00550:  MOVWF  5E
00552:  CLRF   03
00554:  MOVF   57,W
00556:  RCALL  0004
00558:  MOVWF  5F
0055A:  MOVFF  5D,69
0055E:  MOVLW  3F
00560:  MOVWF  x6A
00562:  MOVFF  5E,6B
00566:  MOVFF  5F,6C
0056A:  RCALL  0028
....................    xuat_32led_don_4byte(0,0,0xff,0xff);  delay_ms(dl);         
0056C:  CLRF   5D
0056E:  CLRF   5E
00570:  SETF   5F
00572:  SETF   x60
00574:  RCALL  02FC
00576:  MOVFF  5A,5D
0057A:  INCF   5D,F
0057C:  DECF   5D,F
0057E:  BTFSC  FD8.2
00580:  BRA    0588
00582:  SETF   x6A
00584:  RCALL  00B0
00586:  BRA    057C
00588:  MOVFF  59,6A
0058C:  RCALL  00B0
0058E:  GOTO   12C2 (RETURN)
.................... }   
.................... 
.................... void b303_32led_chop_tat(unsigned int32 dl)                 
.................... {         
....................  bienDem = get_rtcc();
00592:  MOVF   FD6,W
00594:  MOVWF  56
....................   if (inputcd(INV) == 0)
00596:  MOVLW  7C
00598:  MOVWF  x67
0059A:  MOVLW  0E
0059C:  MOVWF  x66
0059E:  RCALL  0206
005A0:  MOVF   01,F
005A2:  BNZ   05B4
....................       {
....................          trangThaiDem = ~trangThaiDem;
005A4:  BTG    0E.3
....................          if(trangThaiDem)
005A6:  BTFSS  0E.3
005A8:  BRA    05AE
....................          {
....................             setup_timer_0(RTCC_OFF);
005AA:  CLRF   FD5
....................          }else
005AC:  BRA    05B4
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
005AE:  BCF    FD1.0
005B0:  MOVLW  A8
005B2:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................   if(bienDem>24)
005B4:  MOVF   56,W
005B6:  SUBLW  18
005B8:  BC    05C2
....................    {
....................      bienDem = 0; 
005BA:  CLRF   56
....................      set_rtcc(0);
005BC:  CLRF   FD7
005BE:  CLRF   FD6
005C0:  NOP   
....................    }
....................  hangDonVi = bienDem%10;
005C2:  MOVFF  56,66
005C6:  MOVLW  0A
005C8:  MOVWF  x67
005CA:  RCALL  02D4
005CC:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
005D0:  MOVFF  56,66
005D4:  MOVLW  0A
005D6:  MOVWF  x67
005D8:  RCALL  02D4
005DA:  MOVFF  01,58
....................   xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
005DE:  CLRF   03
005E0:  MOVF   55,W
005E2:  MOVWF  00
005E4:  BTFSC  FE8.7
005E6:  DECF   03,F
005E8:  RCALL  0004
005EA:  MOVWF  5D
005EC:  CLRF   03
005EE:  MOVF   58,W
005F0:  RCALL  0004
005F2:  MOVWF  5E
005F4:  CLRF   03
005F6:  MOVF   57,W
005F8:  RCALL  0004
005FA:  MOVWF  5F
005FC:  MOVFF  5D,69
00600:  MOVLW  3F
00602:  MOVWF  x6A
00604:  MOVFF  5E,6B
00608:  MOVFF  5F,6C
0060C:  RCALL  0028
....................    xuat_32led_don_4byte(0,0,0,0);     delay_ms(dl);  
0060E:  CLRF   5D
00610:  CLRF   5E
00612:  CLRF   5F
00614:  CLRF   x60
00616:  RCALL  02FC
00618:  MOVFF  5A,5D
0061C:  INCF   5D,F
0061E:  DECF   5D,F
00620:  BTFSC  FD8.2
00622:  BRA    062A
00624:  SETF   x6A
00626:  RCALL  00B0
00628:  BRA    061E
0062A:  MOVFF  59,6A
0062E:  RCALL  00B0
....................     bienDem = get_rtcc();
00630:  MOVF   FD6,W
00632:  MOVWF  56
....................      if (inputcd(INV) == 0)
00634:  MOVLW  7C
00636:  MOVWF  x67
00638:  MOVLW  0E
0063A:  MOVWF  x66
0063C:  RCALL  0206
0063E:  MOVF   01,F
00640:  BNZ   0652
....................       {
....................          trangThaiDem = ~trangThaiDem;
00642:  BTG    0E.3
....................          if(trangThaiDem)
00644:  BTFSS  0E.3
00646:  BRA    064C
....................          {
....................             setup_timer_0(RTCC_OFF);
00648:  CLRF   FD5
....................          }else
0064A:  BRA    0652
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
0064C:  BCF    FD1.0
0064E:  MOVLW  A8
00650:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00652:  MOVF   56,W
00654:  SUBLW  18
00656:  BC    0660
....................    {
....................      bienDem = 0; 
00658:  CLRF   56
....................      set_rtcc(0);
0065A:  CLRF   FD7
0065C:  CLRF   FD6
0065E:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00660:  MOVFF  56,66
00664:  MOVLW  0A
00666:  MOVWF  x67
00668:  RCALL  02D4
0066A:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0066E:  MOVFF  56,66
00672:  MOVLW  0A
00674:  MOVWF  x67
00676:  RCALL  02D4
00678:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0067C:  CLRF   03
0067E:  MOVF   55,W
00680:  MOVWF  00
00682:  BTFSC  FE8.7
00684:  DECF   03,F
00686:  RCALL  0004
00688:  MOVWF  5D
0068A:  CLRF   03
0068C:  MOVF   58,W
0068E:  RCALL  0004
00690:  MOVWF  5E
00692:  CLRF   03
00694:  MOVF   57,W
00696:  RCALL  0004
00698:  MOVWF  5F
0069A:  MOVFF  5D,69
0069E:  MOVLW  3F
006A0:  MOVWF  x6A
006A2:  MOVFF  5E,6B
006A6:  MOVFF  5F,6C
006AA:  RCALL  0028
....................    xuat_32led_don_4byte(0xff,0xff,0xff,0xff);  delay_ms(dl);         
006AC:  SETF   5D
006AE:  SETF   5E
006B0:  SETF   5F
006B2:  SETF   x60
006B4:  RCALL  02FC
006B6:  MOVFF  5A,5D
006BA:  INCF   5D,F
006BC:  DECF   5D,F
006BE:  BTFSC  FD8.2
006C0:  BRA    06C8
006C2:  SETF   x6A
006C4:  RCALL  00B0
006C6:  BRA    06BC
006C8:  MOVFF  59,6A
006CC:  RCALL  00B0
006CE:  GOTO   1326 (RETURN)
.................... } 
.................... void b304_16led_phai_std_pst(unsigned int32 dl)                 
.................... {                           
....................    unsigned int8 i; unsigned int32 LP;
....................    LP = 0;
*
00710:  CLRF   x61
00712:  CLRF   x60
00714:  CLRF   5F
00716:  CLRF   5E
....................    for(i=0;i<16;i++)
00718:  CLRF   5D
0071A:  MOVF   5D,W
0071C:  SUBLW  0F
0071E:  BNC   07F4
....................    {
....................     bienDem = get_rtcc();
00720:  MOVF   FD6,W
00722:  MOVWF  56
....................      if (inputcd(INV) == 0)
00724:  MOVLW  7C
00726:  MOVWF  x67
00728:  MOVLW  0E
0072A:  MOVWF  x66
0072C:  RCALL  0206
0072E:  MOVF   01,F
00730:  BNZ   0742
....................       {
....................          trangThaiDem = ~trangThaiDem;
00732:  BTG    0E.3
....................          if(trangThaiDem)
00734:  BTFSS  0E.3
00736:  BRA    073C
....................          {
....................             setup_timer_0(RTCC_OFF);
00738:  CLRF   FD5
....................          }else
0073A:  BRA    0742
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
0073C:  BCF    FD1.0
0073E:  MOVLW  A8
00740:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00742:  MOVF   56,W
00744:  SUBLW  18
00746:  BC    0750
....................    {
....................      bienDem = 0; 
00748:  CLRF   56
....................      set_rtcc(0);
0074A:  CLRF   FD7
0074C:  CLRF   FD6
0074E:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00750:  MOVFF  56,66
00754:  MOVLW  0A
00756:  MOVWF  x67
00758:  RCALL  02D4
0075A:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0075E:  MOVFF  56,66
00762:  MOVLW  0A
00764:  MOVWF  x67
00766:  RCALL  02D4
00768:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0076C:  CLRF   03
0076E:  MOVF   55,W
00770:  MOVWF  00
00772:  BTFSC  FE8.7
00774:  DECF   03,F
00776:  RCALL  0004
00778:  MOVWF  x62
0077A:  CLRF   03
0077C:  MOVF   58,W
0077E:  RCALL  0004
00780:  MOVWF  x63
00782:  CLRF   03
00784:  MOVF   57,W
00786:  RCALL  0004
00788:  MOVWF  x64
0078A:  MOVFF  62,69
0078E:  MOVLW  3F
00790:  MOVWF  x6A
00792:  MOVFF  63,6B
00796:  MOVFF  64,6C
0079A:  RCALL  0028
....................       LP = (LP<<1)+1;
0079C:  BCF    FD8.0
0079E:  RLCF   5E,W
007A0:  MOVWF  x63
007A2:  RLCF   5F,W
007A4:  MOVWF  x64
007A6:  RLCF   x60,W
007A8:  MOVWF  x65
007AA:  RLCF   x61,W
007AC:  MOVWF  x66
007AE:  MOVLW  01
007B0:  ADDWF  x63,W
007B2:  MOVWF  5E
007B4:  MOVLW  00
007B6:  ADDWFC x64,W
007B8:  MOVWF  5F
007BA:  MOVLW  00
007BC:  ADDWFC x65,W
007BE:  MOVWF  x60
007C0:  MOVLW  00
007C2:  ADDWFC x66,W
007C4:  MOVWF  x61
....................       xuat_32led_don_2word(0,LP);       delay_ms(dl);  
007C6:  MOVFF  5F,63
007CA:  CLRF   x6B
007CC:  CLRF   x6A
007CE:  MOVFF  5F,6D
007D2:  MOVFF  5E,6C
007D6:  RCALL  06D2
007D8:  MOVFF  5A,62
007DC:  INCF   x62,F
007DE:  DECF   x62,F
007E0:  BTFSC  FD8.2
007E2:  BRA    07EA
007E4:  SETF   x6A
007E6:  RCALL  00B0
007E8:  BRA    07DE
007EA:  MOVFF  59,6A
007EE:  RCALL  00B0
007F0:  INCF   5D,F
007F2:  BRA    071A
....................    }
....................     for(i=0;i<16;i++)
007F4:  CLRF   5D
007F6:  MOVF   5D,W
007F8:  SUBLW  0F
007FA:  BNC   08BA
....................    {
....................     bienDem = get_rtcc();
007FC:  MOVF   FD6,W
007FE:  MOVWF  56
....................      if (inputcd(INV) == 0)
00800:  MOVLW  7C
00802:  MOVWF  x67
00804:  MOVLW  0E
00806:  MOVWF  x66
00808:  RCALL  0206
0080A:  MOVF   01,F
0080C:  BNZ   081E
....................       {
....................          trangThaiDem = ~trangThaiDem;
0080E:  BTG    0E.3
....................          if(trangThaiDem)
00810:  BTFSS  0E.3
00812:  BRA    0818
....................          {
....................             setup_timer_0(RTCC_OFF);
00814:  CLRF   FD5
....................          }else
00816:  BRA    081E
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00818:  BCF    FD1.0
0081A:  MOVLW  A8
0081C:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
0081E:  MOVF   56,W
00820:  SUBLW  18
00822:  BC    082C
....................    {
....................      bienDem = 0; 
00824:  CLRF   56
....................      set_rtcc(0);
00826:  CLRF   FD7
00828:  CLRF   FD6
0082A:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
0082C:  MOVFF  56,66
00830:  MOVLW  0A
00832:  MOVWF  x67
00834:  RCALL  02D4
00836:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0083A:  MOVFF  56,66
0083E:  MOVLW  0A
00840:  MOVWF  x67
00842:  RCALL  02D4
00844:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
00848:  CLRF   03
0084A:  MOVF   55,W
0084C:  MOVWF  00
0084E:  BTFSC  FE8.7
00850:  DECF   03,F
00852:  CALL   0004
00856:  MOVWF  x62
00858:  CLRF   03
0085A:  MOVF   58,W
0085C:  CALL   0004
00860:  MOVWF  x63
00862:  CLRF   03
00864:  MOVF   57,W
00866:  CALL   0004
0086A:  MOVWF  x64
0086C:  MOVFF  62,69
00870:  MOVLW  3F
00872:  MOVWF  x6A
00874:  MOVFF  63,6B
00878:  MOVFF  64,6C
0087C:  CALL   0028
....................       LP = (LP<<1);
00880:  BCF    FD8.0
00882:  RLCF   5E,F
00884:  RLCF   5F,F
00886:  RLCF   x60,F
00888:  RLCF   x61,F
....................       xuat_32led_don_2word(0,LP);       delay_ms(dl); 
0088A:  MOVFF  5F,63
0088E:  CLRF   x6B
00890:  CLRF   x6A
00892:  MOVFF  5F,6D
00896:  MOVFF  5E,6C
0089A:  RCALL  06D2
0089C:  MOVFF  5A,62
008A0:  INCF   x62,F
008A2:  DECF   x62,F
008A4:  BTFSC  FD8.2
008A6:  BRA    08AE
008A8:  SETF   x6A
008AA:  RCALL  00B0
008AC:  BRA    08A2
008AE:  MOVFF  59,6A
008B2:  CALL   00B0
008B6:  INCF   5D,F
008B8:  BRA    07F6
....................    }                                        
008BA:  GOTO   1388 (RETURN)
.................... }
.................... void b305_16led_trai_std_tsp(unsigned int32 dl)                 
.................... {                           
....................    unsigned int8 i; unsigned int32 LT;
....................    LT = 0;
008BE:  CLRF   x61
008C0:  CLRF   x60
008C2:  CLRF   5F
008C4:  CLRF   5E
....................    for(i=0;i<16;i++)
008C6:  CLRF   5D
008C8:  MOVF   5D,W
008CA:  SUBLW  0F
008CC:  BNC   09A8
....................    {
....................     bienDem = get_rtcc();
008CE:  MOVF   FD6,W
008D0:  MOVWF  56
....................      if (inputcd(INV) == 0)
008D2:  MOVLW  7C
008D4:  MOVWF  x67
008D6:  MOVLW  0E
008D8:  MOVWF  x66
008DA:  RCALL  0206
008DC:  MOVF   01,F
008DE:  BNZ   08F0
....................       {
....................          trangThaiDem = ~trangThaiDem;
008E0:  BTG    0E.3
....................          if(trangThaiDem)
008E2:  BTFSS  0E.3
008E4:  BRA    08EA
....................          {
....................             setup_timer_0(RTCC_OFF);
008E6:  CLRF   FD5
....................          }else
008E8:  BRA    08F0
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
008EA:  BCF    FD1.0
008EC:  MOVLW  A8
008EE:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
008F0:  MOVF   56,W
008F2:  SUBLW  18
008F4:  BC    08FE
....................    {
....................      bienDem = 0; 
008F6:  CLRF   56
....................      set_rtcc(0);
008F8:  CLRF   FD7
008FA:  CLRF   FD6
008FC:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
008FE:  MOVFF  56,66
00902:  MOVLW  0A
00904:  MOVWF  x67
00906:  RCALL  02D4
00908:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0090C:  MOVFF  56,66
00910:  MOVLW  0A
00912:  MOVWF  x67
00914:  RCALL  02D4
00916:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0091A:  CLRF   03
0091C:  MOVF   55,W
0091E:  MOVWF  00
00920:  BTFSC  FE8.7
00922:  DECF   03,F
00924:  CALL   0004
00928:  MOVWF  x62
0092A:  CLRF   03
0092C:  MOVF   58,W
0092E:  CALL   0004
00932:  MOVWF  x63
00934:  CLRF   03
00936:  MOVF   57,W
00938:  CALL   0004
0093C:  MOVWF  x64
0093E:  MOVFF  62,69
00942:  MOVLW  3F
00944:  MOVWF  x6A
00946:  MOVFF  63,6B
0094A:  MOVFF  64,6C
0094E:  CALL   0028
....................       LT = (LT>>1)+0x8000;
00952:  BCF    FD8.0
00954:  RRCF   x61,W
00956:  MOVWF  x66
00958:  RRCF   x60,W
0095A:  MOVWF  x65
0095C:  RRCF   5F,W
0095E:  MOVWF  x64
00960:  RRCF   5E,W
00962:  MOVWF  5E
00964:  MOVLW  80
00966:  ADDWF  x64,W
00968:  MOVWF  5F
0096A:  MOVLW  00
0096C:  ADDWFC x65,W
0096E:  MOVWF  x60
00970:  MOVLW  00
00972:  ADDWFC x66,W
00974:  MOVWF  x61
....................       xuat_32led_don_2word(LT,0);       delay_ms(dl);  
00976:  MOVFF  5F,63
0097A:  MOVFF  5F,6B
0097E:  MOVFF  5E,6A
00982:  CLRF   x6D
00984:  CLRF   x6C
00986:  RCALL  06D2
00988:  MOVFF  5A,62
0098C:  INCF   x62,F
0098E:  DECF   x62,F
00990:  BTFSC  FD8.2
00992:  BRA    099C
00994:  SETF   x6A
00996:  CALL   00B0
0099A:  BRA    098E
0099C:  MOVFF  59,6A
009A0:  CALL   00B0
009A4:  INCF   5D,F
009A6:  BRA    08C8
....................    }
....................     for(i=0;i<16;i++)
009A8:  CLRF   5D
009AA:  MOVF   5D,W
009AC:  SUBLW  0F
009AE:  BNC   0A38
....................    {
....................     bienDem = get_rtcc();
009B0:  MOVF   FD6,W
009B2:  MOVWF  56
....................      if (inputcd(INV) == 0)
009B4:  MOVLW  7C
009B6:  MOVWF  x67
009B8:  MOVLW  0E
009BA:  MOVWF  x66
009BC:  RCALL  0206
009BE:  MOVF   01,F
009C0:  BNZ   09D2
....................       {
....................          trangThaiDem = ~trangThaiDem;
009C2:  BTG    0E.3
....................          if(trangThaiDem)
009C4:  BTFSS  0E.3
009C6:  BRA    09CC
....................          {
....................             setup_timer_0(RTCC_OFF);
009C8:  CLRF   FD5
....................          }else
009CA:  BRA    09D2
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
009CC:  BCF    FD1.0
009CE:  MOVLW  A8
009D0:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
009D2:  MOVF   56,W
009D4:  SUBLW  18
009D6:  BC    09E0
....................    {
....................      bienDem = 0; 
009D8:  CLRF   56
....................      set_rtcc(0);
009DA:  CLRF   FD7
009DC:  CLRF   FD6
009DE:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
009E0:  MOVFF  56,66
009E4:  MOVLW  0A
009E6:  MOVWF  x67
009E8:  RCALL  02D4
009EA:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
009EE:  MOVFF  56,66
009F2:  MOVLW  0A
009F4:  MOVWF  x67
009F6:  RCALL  02D4
009F8:  MOVFF  01,58
....................       LT = (LT>>1);
009FC:  BCF    FD8.0
009FE:  RRCF   x61,F
00A00:  RRCF   x60,F
00A02:  RRCF   5F,F
00A04:  RRCF   5E,F
....................       xuat_32led_don_2word(LT,0);       delay_ms(dl); 
00A06:  MOVFF  5F,63
00A0A:  MOVFF  5F,6B
00A0E:  MOVFF  5E,6A
00A12:  CLRF   x6D
00A14:  CLRF   x6C
00A16:  RCALL  06D2
00A18:  MOVFF  5A,62
00A1C:  INCF   x62,F
00A1E:  DECF   x62,F
00A20:  BTFSC  FD8.2
00A22:  BRA    0A2C
00A24:  SETF   x6A
00A26:  CALL   00B0
00A2A:  BRA    0A1E
00A2C:  MOVFF  59,6A
00A30:  CALL   00B0
00A34:  INCF   5D,F
00A36:  BRA    09AA
....................    }                                        
00A38:  GOTO   13EA (RETURN)
.................... }   
.................... void b306_32led_std_tnv(unsigned int32 dl)                 
.................... {                           
....................    unsigned int8 i; unsigned int32 LT, LP;
....................    LT = 0;  LP = 0;
00A3C:  CLRF   x61
00A3E:  CLRF   x60
00A40:  CLRF   5F
00A42:  CLRF   5E
00A44:  CLRF   x65
00A46:  CLRF   x64
00A48:  CLRF   x63
00A4A:  CLRF   x62
....................    for(i=0;i<16;i++)
00A4C:  CLRF   5D
00A4E:  MOVF   5D,W
00A50:  SUBLW  0F
00A52:  BTFSS  FD8.0
00A54:  BRA    0B68
....................    {
....................     bienDem = get_rtcc();
00A56:  MOVF   FD6,W
00A58:  MOVWF  56
....................      if (inputcd(INV) == 0)
00A5A:  MOVLW  7C
00A5C:  MOVWF  x67
00A5E:  MOVLW  0E
00A60:  MOVWF  x66
00A62:  CALL   0206
00A66:  MOVF   01,F
00A68:  BNZ   0A7A
....................       {
....................          trangThaiDem = ~trangThaiDem;
00A6A:  BTG    0E.3
....................          if(trangThaiDem)
00A6C:  BTFSS  0E.3
00A6E:  BRA    0A74
....................          {
....................             setup_timer_0(RTCC_OFF);
00A70:  CLRF   FD5
....................          }else
00A72:  BRA    0A7A
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00A74:  BCF    FD1.0
00A76:  MOVLW  A8
00A78:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00A7A:  MOVF   56,W
00A7C:  SUBLW  18
00A7E:  BC    0A88
....................    {
....................      bienDem = 0; 
00A80:  CLRF   56
....................      set_rtcc(0);
00A82:  CLRF   FD7
00A84:  CLRF   FD6
00A86:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00A88:  MOVFF  56,66
00A8C:  MOVLW  0A
00A8E:  MOVWF  x67
00A90:  RCALL  02D4
00A92:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00A96:  MOVFF  56,66
00A9A:  MOVLW  0A
00A9C:  MOVWF  x67
00A9E:  RCALL  02D4
00AA0:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
00AA4:  CLRF   03
00AA6:  MOVF   55,W
00AA8:  MOVWF  00
00AAA:  BTFSC  FE8.7
00AAC:  DECF   03,F
00AAE:  CALL   0004
00AB2:  MOVWF  x66
00AB4:  CLRF   03
00AB6:  MOVF   58,W
00AB8:  CALL   0004
00ABC:  MOVWF  x67
00ABE:  CLRF   03
00AC0:  MOVF   57,W
00AC2:  CALL   0004
00AC6:  MOVWF  x68
00AC8:  MOVFF  66,69
00ACC:  MOVLW  3F
00ACE:  MOVWF  x6A
00AD0:  MOVFF  67,6B
00AD4:  MOVFF  68,6C
00AD8:  CALL   0028
....................       LT = (LT>>1)+0x8000;
00ADC:  BCF    FD8.0
00ADE:  RRCF   x61,W
00AE0:  MOVWF  x6A
00AE2:  RRCF   x60,W
00AE4:  MOVWF  x69
00AE6:  RRCF   5F,W
00AE8:  MOVWF  x68
00AEA:  RRCF   5E,W
00AEC:  MOVWF  5E
00AEE:  MOVLW  80
00AF0:  ADDWF  x68,W
00AF2:  MOVWF  5F
00AF4:  MOVLW  00
00AF6:  ADDWFC x69,W
00AF8:  MOVWF  x60
00AFA:  MOVLW  00
00AFC:  ADDWFC x6A,W
00AFE:  MOVWF  x61
....................       LP = (LP<<1)+0x0001;
00B00:  BCF    FD8.0
00B02:  RLCF   x62,W
00B04:  MOVWF  x67
00B06:  RLCF   x63,W
00B08:  MOVWF  x68
00B0A:  RLCF   x64,W
00B0C:  MOVWF  x69
00B0E:  RLCF   x65,W
00B10:  MOVWF  x6A
00B12:  MOVLW  01
00B14:  ADDWF  x67,W
00B16:  MOVWF  x62
00B18:  MOVLW  00
00B1A:  ADDWFC x68,W
00B1C:  MOVWF  x63
00B1E:  MOVLW  00
00B20:  ADDWFC x69,W
00B22:  MOVWF  x64
00B24:  MOVLW  00
00B26:  ADDWFC x6A,W
00B28:  MOVWF  x65
....................       xuat_32led_don_2word(LT,LP);       delay_ms(dl);  
00B2A:  MOVFF  5F,67
00B2E:  MOVFF  63,69
00B32:  MOVFF  62,68
00B36:  MOVFF  5F,6B
00B3A:  MOVFF  5E,6A
00B3E:  MOVFF  63,6D
00B42:  MOVFF  62,6C
00B46:  RCALL  06D2
00B48:  MOVFF  5A,66
00B4C:  INCF   x66,F
00B4E:  DECF   x66,F
00B50:  BTFSC  FD8.2
00B52:  BRA    0B5C
00B54:  SETF   x6A
00B56:  CALL   00B0
00B5A:  BRA    0B4E
00B5C:  MOVFF  59,6A
00B60:  CALL   00B0
00B64:  INCF   5D,F
00B66:  BRA    0A4E
....................    }
....................     for(i=0;i<16;i++)
00B68:  CLRF   5D
00B6A:  MOVF   5D,W
00B6C:  SUBLW  0F
00B6E:  BNC   0C4C
....................    {
....................     bienDem = get_rtcc();
00B70:  MOVF   FD6,W
00B72:  MOVWF  56
....................      if (inputcd(INV) == 0)
00B74:  MOVLW  7C
00B76:  MOVWF  x67
00B78:  MOVLW  0E
00B7A:  MOVWF  x66
00B7C:  CALL   0206
00B80:  MOVF   01,F
00B82:  BNZ   0B94
....................       {
....................          trangThaiDem = ~trangThaiDem;
00B84:  BTG    0E.3
....................          if(trangThaiDem)
00B86:  BTFSS  0E.3
00B88:  BRA    0B8E
....................          {
....................             setup_timer_0(RTCC_OFF);
00B8A:  CLRF   FD5
....................          }else
00B8C:  BRA    0B94
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00B8E:  BCF    FD1.0
00B90:  MOVLW  A8
00B92:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00B94:  MOVF   56,W
00B96:  SUBLW  18
00B98:  BC    0BA2
....................    {
....................      bienDem = 0; 
00B9A:  CLRF   56
....................      set_rtcc(0);
00B9C:  CLRF   FD7
00B9E:  CLRF   FD6
00BA0:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00BA2:  MOVFF  56,66
00BA6:  MOVLW  0A
00BA8:  MOVWF  x67
00BAA:  CALL   02D4
00BAE:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00BB2:  MOVFF  56,66
00BB6:  MOVLW  0A
00BB8:  MOVWF  x67
00BBA:  CALL   02D4
00BBE:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
00BC2:  CLRF   03
00BC4:  MOVF   55,W
00BC6:  MOVWF  00
00BC8:  BTFSC  FE8.7
00BCA:  DECF   03,F
00BCC:  CALL   0004
00BD0:  MOVWF  x66
00BD2:  CLRF   03
00BD4:  MOVF   58,W
00BD6:  CALL   0004
00BDA:  MOVWF  x67
00BDC:  CLRF   03
00BDE:  MOVF   57,W
00BE0:  CALL   0004
00BE4:  MOVWF  x68
00BE6:  MOVFF  66,69
00BEA:  MOVLW  3F
00BEC:  MOVWF  x6A
00BEE:  MOVFF  67,6B
00BF2:  MOVFF  68,6C
00BF6:  CALL   0028
....................       LT = (LT>>1);
00BFA:  BCF    FD8.0
00BFC:  RRCF   x61,F
00BFE:  RRCF   x60,F
00C00:  RRCF   5F,F
00C02:  RRCF   5E,F
....................       LP = (LP<<1);
00C04:  BCF    FD8.0
00C06:  RLCF   x62,F
00C08:  RLCF   x63,F
00C0A:  RLCF   x64,F
00C0C:  RLCF   x65,F
....................       xuat_32led_don_2word(LT,LP);       delay_ms(dl); 
00C0E:  MOVFF  5F,67
00C12:  MOVFF  63,69
00C16:  MOVFF  62,68
00C1A:  MOVFF  5F,6B
00C1E:  MOVFF  5E,6A
00C22:  MOVFF  63,6D
00C26:  MOVFF  62,6C
00C2A:  RCALL  06D2
00C2C:  MOVFF  5A,66
00C30:  INCF   x66,F
00C32:  DECF   x66,F
00C34:  BTFSC  FD8.2
00C36:  BRA    0C40
00C38:  SETF   x6A
00C3A:  CALL   00B0
00C3E:  BRA    0C32
00C40:  MOVFF  59,6A
00C44:  CALL   00B0
00C48:  INCF   5D,F
00C4A:  BRA    0B6A
....................    }                                        
00C4C:  GOTO   144C (RETURN)
.................... }
.................... void b307_32led_std_ttr(unsigned int32 dl)                 
.................... {                           
....................    unsigned int8 i; unsigned int32 LT, LP;
....................    LT = 0;  LP = 0;
00C50:  CLRF   x61
00C52:  CLRF   x60
00C54:  CLRF   5F
00C56:  CLRF   5E
00C58:  CLRF   x65
00C5A:  CLRF   x64
00C5C:  CLRF   x63
00C5E:  CLRF   x62
....................    for(i=0;i<16;i++)
00C60:  CLRF   5D
00C62:  MOVF   5D,W
00C64:  SUBLW  0F
00C66:  BTFSS  FD8.0
00C68:  BRA    0D60
....................    {
....................     bienDem = get_rtcc();
00C6A:  MOVF   FD6,W
00C6C:  MOVWF  56
....................      if(bienDem>24)
00C6E:  MOVF   56,W
00C70:  SUBLW  18
00C72:  BC    0C7C
....................    {
....................      bienDem = 0; 
00C74:  CLRF   56
....................      set_rtcc(0);
00C76:  CLRF   FD7
00C78:  CLRF   FD6
00C7A:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00C7C:  MOVFF  56,66
00C80:  MOVLW  0A
00C82:  MOVWF  x67
00C84:  CALL   02D4
00C88:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00C8C:  MOVFF  56,66
00C90:  MOVLW  0A
00C92:  MOVWF  x67
00C94:  CALL   02D4
00C98:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
00C9C:  CLRF   03
00C9E:  MOVF   55,W
00CA0:  MOVWF  00
00CA2:  BTFSC  FE8.7
00CA4:  DECF   03,F
00CA6:  CALL   0004
00CAA:  MOVWF  x66
00CAC:  CLRF   03
00CAE:  MOVF   58,W
00CB0:  CALL   0004
00CB4:  MOVWF  x67
00CB6:  CLRF   03
00CB8:  MOVF   57,W
00CBA:  CALL   0004
00CBE:  MOVWF  x68
00CC0:  MOVFF  66,69
00CC4:  MOVLW  3F
00CC6:  MOVWF  x6A
00CC8:  MOVFF  67,6B
00CCC:  MOVFF  68,6C
00CD0:  CALL   0028
....................       LT = (LT<<1)+0x0001;       LP = (LP>>1)+0x8000;
00CD4:  BCF    FD8.0
00CD6:  RLCF   5E,W
00CD8:  MOVWF  x67
00CDA:  RLCF   5F,W
00CDC:  MOVWF  x68
00CDE:  RLCF   x60,W
00CE0:  MOVWF  x69
00CE2:  RLCF   x61,W
00CE4:  MOVWF  x6A
00CE6:  MOVLW  01
00CE8:  ADDWF  x67,W
00CEA:  MOVWF  5E
00CEC:  MOVLW  00
00CEE:  ADDWFC x68,W
00CF0:  MOVWF  5F
00CF2:  MOVLW  00
00CF4:  ADDWFC x69,W
00CF6:  MOVWF  x60
00CF8:  MOVLW  00
00CFA:  ADDWFC x6A,W
00CFC:  MOVWF  x61
00CFE:  BCF    FD8.0
00D00:  RRCF   x65,W
00D02:  MOVWF  x6A
00D04:  RRCF   x64,W
00D06:  MOVWF  x69
00D08:  RRCF   x63,W
00D0A:  MOVWF  x68
00D0C:  RRCF   x62,W
00D0E:  MOVWF  x62
00D10:  MOVLW  80
00D12:  ADDWF  x68,W
00D14:  MOVWF  x63
00D16:  MOVLW  00
00D18:  ADDWFC x69,W
00D1A:  MOVWF  x64
00D1C:  MOVLW  00
00D1E:  ADDWFC x6A,W
00D20:  MOVWF  x65
....................       xuat_32led_don_2word(LT,LP);    delay_ms(dl);  
00D22:  MOVFF  5F,67
00D26:  MOVFF  63,69
00D2A:  MOVFF  62,68
00D2E:  MOVFF  5F,6B
00D32:  MOVFF  5E,6A
00D36:  MOVFF  63,6D
00D3A:  MOVFF  62,6C
00D3E:  RCALL  06D2
00D40:  MOVFF  5A,66
00D44:  INCF   x66,F
00D46:  DECF   x66,F
00D48:  BTFSC  FD8.2
00D4A:  BRA    0D54
00D4C:  SETF   x6A
00D4E:  CALL   00B0
00D52:  BRA    0D46
00D54:  MOVFF  59,6A
00D58:  CALL   00B0
00D5C:  INCF   5D,F
00D5E:  BRA    0C62
....................    }
....................     for(i=0;i<16;i++)
00D60:  CLRF   5D
00D62:  MOVF   5D,W
00D64:  SUBLW  0F
00D66:  BNC   0E0C
....................    {
....................     bienDem = get_rtcc();
00D68:  MOVF   FD6,W
00D6A:  MOVWF  56
....................      if (inputcd(INV) == 0)
00D6C:  MOVLW  7C
00D6E:  MOVWF  x67
00D70:  MOVLW  0E
00D72:  MOVWF  x66
00D74:  CALL   0206
00D78:  MOVF   01,F
00D7A:  BNZ   0D8C
....................       {
....................          trangThaiDem = ~trangThaiDem;
00D7C:  BTG    0E.3
....................          if(trangThaiDem)
00D7E:  BTFSS  0E.3
00D80:  BRA    0D86
....................          {
....................             setup_timer_0(RTCC_OFF);
00D82:  CLRF   FD5
....................          }else
00D84:  BRA    0D8C
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00D86:  BCF    FD1.0
00D88:  MOVLW  A8
00D8A:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00D8C:  MOVF   56,W
00D8E:  SUBLW  18
00D90:  BC    0D9A
....................    {
....................      bienDem = 0; 
00D92:  CLRF   56
....................      set_rtcc(0);
00D94:  CLRF   FD7
00D96:  CLRF   FD6
00D98:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00D9A:  MOVFF  56,66
00D9E:  MOVLW  0A
00DA0:  MOVWF  x67
00DA2:  CALL   02D4
00DA6:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00DAA:  MOVFF  56,66
00DAE:  MOVLW  0A
00DB0:  MOVWF  x67
00DB2:  CALL   02D4
00DB6:  MOVFF  01,58
....................       LT = (LT<<1);              LP = (LP>>1);                 
00DBA:  BCF    FD8.0
00DBC:  RLCF   5E,F
00DBE:  RLCF   5F,F
00DC0:  RLCF   x60,F
00DC2:  RLCF   x61,F
00DC4:  BCF    FD8.0
00DC6:  RRCF   x65,F
00DC8:  RRCF   x64,F
00DCA:  RRCF   x63,F
00DCC:  RRCF   x62,F
....................       xuat_32led_don_2word(LT,LP);       delay_ms(dl); 
00DCE:  MOVFF  5F,67
00DD2:  MOVFF  63,69
00DD6:  MOVFF  62,68
00DDA:  MOVFF  5F,6B
00DDE:  MOVFF  5E,6A
00DE2:  MOVFF  63,6D
00DE6:  MOVFF  62,6C
00DEA:  RCALL  06D2
00DEC:  MOVFF  5A,66
00DF0:  INCF   x66,F
00DF2:  DECF   x66,F
00DF4:  BTFSC  FD8.2
00DF6:  BRA    0E00
00DF8:  SETF   x6A
00DFA:  CALL   00B0
00DFE:  BRA    0DF2
00E00:  MOVFF  59,6A
00E04:  CALL   00B0
00E08:  INCF   5D,F
00E0A:  BRA    0D62
....................    }                                        
00E0C:  GOTO   14AE (RETURN)
.................... }  
.................... void b308_32led_std_pst(unsigned int32 dl)                 
.................... {                           
....................    unsigned int8 i; unsigned int32 x;
....................    x = 0;  
00E10:  CLRF   x61
00E12:  CLRF   x60
00E14:  CLRF   5F
00E16:  CLRF   5E
....................    for(i=0;i<32;i++)
00E18:  CLRF   5D
00E1A:  MOVF   5D,W
00E1C:  SUBLW  1F
00E1E:  BNC   0EE8
....................    {
....................     bienDem = get_rtcc();
00E20:  MOVF   FD6,W
00E22:  MOVWF  56
....................      if(bienDem>24)
00E24:  MOVF   56,W
00E26:  SUBLW  18
00E28:  BC    0E32
....................    {
....................      bienDem = 0; 
00E2A:  CLRF   56
....................      set_rtcc(0);
00E2C:  CLRF   FD7
00E2E:  CLRF   FD6
00E30:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00E32:  MOVFF  56,66
00E36:  MOVLW  0A
00E38:  MOVWF  x67
00E3A:  CALL   02D4
00E3E:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00E42:  MOVFF  56,66
00E46:  MOVLW  0A
00E48:  MOVWF  x67
00E4A:  CALL   02D4
00E4E:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
00E52:  CLRF   03
00E54:  MOVF   55,W
00E56:  MOVWF  00
00E58:  BTFSC  FE8.7
00E5A:  DECF   03,F
00E5C:  CALL   0004
00E60:  MOVWF  x62
00E62:  CLRF   03
00E64:  MOVF   58,W
00E66:  CALL   0004
00E6A:  MOVWF  x63
00E6C:  CLRF   03
00E6E:  MOVF   57,W
00E70:  CALL   0004
00E74:  MOVWF  x64
00E76:  MOVFF  62,69
00E7A:  MOVLW  3F
00E7C:  MOVWF  x6A
00E7E:  MOVFF  63,6B
00E82:  MOVFF  64,6C
00E86:  CALL   0028
....................       x = (x<<1)+1;         
00E8A:  BCF    FD8.0
00E8C:  RLCF   5E,W
00E8E:  MOVWF  x63
00E90:  RLCF   5F,W
00E92:  MOVWF  x64
00E94:  RLCF   x60,W
00E96:  MOVWF  x65
00E98:  RLCF   x61,W
00E9A:  MOVWF  x66
00E9C:  MOVLW  01
00E9E:  ADDWF  x63,W
00EA0:  MOVWF  5E
00EA2:  MOVLW  00
00EA4:  ADDWFC x64,W
00EA6:  MOVWF  5F
00EA8:  MOVLW  00
00EAA:  ADDWFC x65,W
00EAC:  MOVWF  x60
00EAE:  MOVLW  00
00EB0:  ADDWFC x66,W
00EB2:  MOVWF  x61
....................       xuat_32led_don_1dw(x);    delay_ms(dl);  
00EB4:  MOVFF  61,65
00EB8:  MOVFF  60,64
00EBC:  MOVFF  5F,63
00EC0:  MOVFF  5E,62
00EC4:  CALL   005A
00EC8:  MOVFF  5A,62
00ECC:  INCF   x62,F
00ECE:  DECF   x62,F
00ED0:  BTFSC  FD8.2
00ED2:  BRA    0EDC
00ED4:  SETF   x6A
00ED6:  CALL   00B0
00EDA:  BRA    0ECE
00EDC:  MOVFF  59,6A
00EE0:  CALL   00B0
00EE4:  INCF   5D,F
00EE6:  BRA    0E1A
....................    }
....................     for(i=0;i<32;i++)
00EE8:  CLRF   5D
00EEA:  MOVF   5D,W
00EEC:  SUBLW  1F
00EEE:  BNC   0FB8
....................    {
....................     bienDem = get_rtcc();
00EF0:  MOVF   FD6,W
00EF2:  MOVWF  56
....................      if (inputcd(INV) == 0)
00EF4:  MOVLW  7C
00EF6:  MOVWF  x67
00EF8:  MOVLW  0E
00EFA:  MOVWF  x66
00EFC:  CALL   0206
00F00:  MOVF   01,F
00F02:  BNZ   0F14
....................       {
....................          trangThaiDem = ~trangThaiDem;
00F04:  BTG    0E.3
....................          if(trangThaiDem)
00F06:  BTFSS  0E.3
00F08:  BRA    0F0E
....................          {
....................             setup_timer_0(RTCC_OFF);
00F0A:  CLRF   FD5
....................          }else
00F0C:  BRA    0F14
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00F0E:  BCF    FD1.0
00F10:  MOVLW  A8
00F12:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00F14:  MOVF   56,W
00F16:  SUBLW  18
00F18:  BC    0F22
....................    {
....................      bienDem = 0; 
00F1A:  CLRF   56
....................      set_rtcc(0);
00F1C:  CLRF   FD7
00F1E:  CLRF   FD6
00F20:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00F22:  MOVFF  56,66
00F26:  MOVLW  0A
00F28:  MOVWF  x67
00F2A:  CALL   02D4
00F2E:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
00F32:  MOVFF  56,66
00F36:  MOVLW  0A
00F38:  MOVWF  x67
00F3A:  CALL   02D4
00F3E:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
00F42:  CLRF   03
00F44:  MOVF   55,W
00F46:  MOVWF  00
00F48:  BTFSC  FE8.7
00F4A:  DECF   03,F
00F4C:  CALL   0004
00F50:  MOVWF  x62
00F52:  CLRF   03
00F54:  MOVF   58,W
00F56:  CALL   0004
00F5A:  MOVWF  x63
00F5C:  CLRF   03
00F5E:  MOVF   57,W
00F60:  CALL   0004
00F64:  MOVWF  x64
00F66:  MOVFF  62,69
00F6A:  MOVLW  3F
00F6C:  MOVWF  x6A
00F6E:  MOVFF  63,6B
00F72:  MOVFF  64,6C
00F76:  CALL   0028
....................       x = (x<<1);
00F7A:  BCF    FD8.0
00F7C:  RLCF   5E,F
00F7E:  RLCF   5F,F
00F80:  RLCF   x60,F
00F82:  RLCF   x61,F
....................       xuat_32led_don_1dw(x);    delay_ms(dl); 
00F84:  MOVFF  61,65
00F88:  MOVFF  60,64
00F8C:  MOVFF  5F,63
00F90:  MOVFF  5E,62
00F94:  CALL   005A
00F98:  MOVFF  5A,62
00F9C:  INCF   x62,F
00F9E:  DECF   x62,F
00FA0:  BTFSC  FD8.2
00FA2:  BRA    0FAC
00FA4:  SETF   x6A
00FA6:  CALL   00B0
00FAA:  BRA    0F9E
00FAC:  MOVFF  59,6A
00FB0:  CALL   00B0
00FB4:  INCF   5D,F
00FB6:  BRA    0EEA
....................    }                                        
00FB8:  GOTO   150E (RETURN)
.................... } 
.................... void b309_32led_std_tsp(unsigned int32 dl)                 
.................... {                           
....................    unsigned int8 i; unsigned int32 x;
....................    x = 0;  
00FBC:  CLRF   x61
00FBE:  CLRF   x60
00FC0:  CLRF   5F
00FC2:  CLRF   5E
....................    for(i=0;i<32;i++)
00FC4:  CLRF   5D
00FC6:  MOVF   5D,W
00FC8:  SUBLW  1F
00FCA:  BNC   10AA
....................    {
....................     bienDem = get_rtcc();
00FCC:  MOVF   FD6,W
00FCE:  MOVWF  56
....................      if (inputcd(INV) == 0)
00FD0:  MOVLW  7C
00FD2:  MOVWF  x67
00FD4:  MOVLW  0E
00FD6:  MOVWF  x66
00FD8:  CALL   0206
00FDC:  MOVF   01,F
00FDE:  BNZ   0FF0
....................       {
....................          trangThaiDem = ~trangThaiDem;
00FE0:  BTG    0E.3
....................          if(trangThaiDem)
00FE2:  BTFSS  0E.3
00FE4:  BRA    0FEA
....................          {
....................             setup_timer_0(RTCC_OFF);
00FE6:  CLRF   FD5
....................          }else
00FE8:  BRA    0FF0
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
00FEA:  BCF    FD1.0
00FEC:  MOVLW  A8
00FEE:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
00FF0:  MOVF   56,W
00FF2:  SUBLW  18
00FF4:  BC    0FFE
....................    {
....................      bienDem = 0; 
00FF6:  CLRF   56
....................      set_rtcc(0);
00FF8:  CLRF   FD7
00FFA:  CLRF   FD6
00FFC:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
00FFE:  MOVFF  56,66
01002:  MOVLW  0A
01004:  MOVWF  x67
01006:  CALL   02D4
0100A:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
0100E:  MOVFF  56,66
01012:  MOVLW  0A
01014:  MOVWF  x67
01016:  CALL   02D4
0101A:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0101E:  CLRF   03
01020:  MOVF   55,W
01022:  MOVWF  00
01024:  BTFSC  FE8.7
01026:  DECF   03,F
01028:  CALL   0004
0102C:  MOVWF  x62
0102E:  CLRF   03
01030:  MOVF   58,W
01032:  CALL   0004
01036:  MOVWF  x63
01038:  CLRF   03
0103A:  MOVF   57,W
0103C:  CALL   0004
01040:  MOVWF  x64
01042:  MOVFF  62,69
01046:  MOVLW  3F
01048:  MOVWF  x6A
0104A:  MOVFF  63,6B
0104E:  MOVFF  64,6C
01052:  CALL   0028
....................       x = (x>>1)+0x80000000;         
01056:  BCF    FD8.0
01058:  RRCF   x61,W
0105A:  MOVWF  x66
0105C:  RRCF   x60,W
0105E:  MOVWF  x65
01060:  RRCF   5F,W
01062:  MOVWF  x64
01064:  RRCF   5E,W
01066:  MOVWF  5E
01068:  MOVFF  64,5F
0106C:  MOVFF  65,60
01070:  MOVLW  80
01072:  ADDWF  x66,W
01074:  MOVWF  x61
....................       xuat_32led_don_1dw(x);    delay_ms(dl);  
01076:  MOVFF  61,65
0107A:  MOVFF  60,64
0107E:  MOVFF  5F,63
01082:  MOVFF  5E,62
01086:  CALL   005A
0108A:  MOVFF  5A,62
0108E:  INCF   x62,F
01090:  DECF   x62,F
01092:  BTFSC  FD8.2
01094:  BRA    109E
01096:  SETF   x6A
01098:  CALL   00B0
0109C:  BRA    1090
0109E:  MOVFF  59,6A
010A2:  CALL   00B0
010A6:  INCF   5D,F
010A8:  BRA    0FC6
....................    }
....................     for(i=0;i<32;i++)
010AA:  CLRF   5D
010AC:  MOVF   5D,W
010AE:  SUBLW  1F
010B0:  BNC   117A
....................    {
....................     bienDem = get_rtcc();
010B2:  MOVF   FD6,W
010B4:  MOVWF  56
....................      if (inputcd(INV) == 0)
010B6:  MOVLW  7C
010B8:  MOVWF  x67
010BA:  MOVLW  0E
010BC:  MOVWF  x66
010BE:  CALL   0206
010C2:  MOVF   01,F
010C4:  BNZ   10D6
....................       {
....................          trangThaiDem = ~trangThaiDem;
010C6:  BTG    0E.3
....................          if(trangThaiDem)
010C8:  BTFSS  0E.3
010CA:  BRA    10D0
....................          {
....................             setup_timer_0(RTCC_OFF);
010CC:  CLRF   FD5
....................          }else
010CE:  BRA    10D6
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
010D0:  BCF    FD1.0
010D2:  MOVLW  A8
010D4:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
....................      if(bienDem>24)
010D6:  MOVF   56,W
010D8:  SUBLW  18
010DA:  BC    10E4
....................    {
....................      bienDem = 0; 
010DC:  CLRF   56
....................      set_rtcc(0);
010DE:  CLRF   FD7
010E0:  CLRF   FD6
010E2:  NOP   
....................    }
....................     hangDonVi = bienDem%10;
010E4:  MOVFF  56,66
010E8:  MOVLW  0A
010EA:  MOVWF  x67
010EC:  CALL   02D4
010F0:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
010F4:  MOVFF  56,66
010F8:  MOVLW  0A
010FA:  MOVWF  x67
010FC:  CALL   02D4
01100:  MOVFF  01,58
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01104:  CLRF   03
01106:  MOVF   55,W
01108:  MOVWF  00
0110A:  BTFSC  FE8.7
0110C:  DECF   03,F
0110E:  CALL   0004
01112:  MOVWF  x62
01114:  CLRF   03
01116:  MOVF   58,W
01118:  CALL   0004
0111C:  MOVWF  x63
0111E:  CLRF   03
01120:  MOVF   57,W
01122:  CALL   0004
01126:  MOVWF  x64
01128:  MOVFF  62,69
0112C:  MOVLW  3F
0112E:  MOVWF  x6A
01130:  MOVFF  63,6B
01134:  MOVFF  64,6C
01138:  CALL   0028
....................       x = (x>>1);
0113C:  BCF    FD8.0
0113E:  RRCF   x61,F
01140:  RRCF   x60,F
01142:  RRCF   5F,F
01144:  RRCF   5E,F
....................       xuat_32led_don_1dw(x);    delay_ms(dl); 
01146:  MOVFF  61,65
0114A:  MOVFF  60,64
0114E:  MOVFF  5F,63
01152:  MOVFF  5E,62
01156:  CALL   005A
0115A:  MOVFF  5A,62
0115E:  INCF   x62,F
01160:  DECF   x62,F
01162:  BTFSC  FD8.2
01164:  BRA    116E
01166:  SETF   x6A
01168:  CALL   00B0
0116C:  BRA    1160
0116E:  MOVFF  59,6A
01172:  CALL   00B0
01176:  INCF   5D,F
01178:  BRA    10AC
....................    }                                        
0117A:  GOTO   156E (RETURN)
.................... } 
.................... 
.................... void led()
.................... {
.................... 
....................     if(inputcd(DW)==0)
0117E:  MOVLW  7C
01180:  MOVWF  x67
01182:  MOVLW  0D
01184:  MOVWF  x66
01186:  CALL   0206
0118A:  MOVF   01,F
0118C:  BNZ   1190
....................     {
....................       ledRun = 0;
0118E:  BCF    0E.2
....................     }
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01190:  CLRF   03
01192:  MOVF   55,W
01194:  MOVWF  00
01196:  BTFSC  FE8.7
01198:  DECF   03,F
0119A:  CALL   0004
0119E:  MOVWF  59
011A0:  CLRF   03
011A2:  MOVF   58,W
011A4:  CALL   0004
011A8:  MOVWF  5A
011AA:  CLRF   03
011AC:  MOVF   57,W
011AE:  CALL   0004
011B2:  MOVWF  5B
011B4:  MOVFF  59,69
011B8:  MOVLW  3F
011BA:  MOVWF  x6A
011BC:  MOVFF  5A,6B
011C0:  MOVFF  5B,6C
011C4:  CALL   0028
....................    if(ledRun == 1)
011C8:  BTFSS  0E.2
011CA:  BRA    125E
....................    {
....................     bienDem = get_rtcc();
011CC:  MOVF   FD6,W
011CE:  MOVWF  56
....................      if(bienDem>24)
011D0:  MOVF   56,W
011D2:  SUBLW  18
011D4:  BC    11DE
....................    {
....................      bienDem = 0; 
011D6:  CLRF   56
....................      set_rtcc(0);
011D8:  CLRF   FD7
011DA:  CLRF   FD6
011DC:  NOP   
....................    }
....................      xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
011DE:  CLRF   03
011E0:  MOVF   55,W
011E2:  MOVWF  00
011E4:  BTFSC  FE8.7
011E6:  DECF   03,F
011E8:  CALL   0004
011EC:  MOVWF  59
011EE:  CLRF   03
011F0:  MOVF   58,W
011F2:  CALL   0004
011F6:  MOVWF  5A
011F8:  CLRF   03
011FA:  MOVF   57,W
011FC:  CALL   0004
01200:  MOVWF  5B
01202:  MOVFF  59,69
01206:  MOVLW  3F
01208:  MOVWF  x6A
0120A:  MOVFF  5A,6B
0120E:  MOVFF  5B,6C
01212:  CALL   0028
....................       b301_8led_chop_tat(1000);
01216:  CLRF   5C
01218:  CLRF   5B
0121A:  MOVLW  03
0121C:  MOVWF  5A
0121E:  MOVLW  E8
01220:  MOVWF  59
01222:  GOTO   032E
....................       xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01226:  CLRF   03
01228:  MOVF   55,W
0122A:  MOVWF  00
0122C:  BTFSC  FE8.7
0122E:  DECF   03,F
01230:  CALL   0004
01234:  MOVWF  59
01236:  CLRF   03
01238:  MOVF   58,W
0123A:  CALL   0004
0123E:  MOVWF  5A
01240:  CLRF   03
01242:  MOVF   57,W
01244:  CALL   0004
01248:  MOVWF  5B
0124A:  MOVFF  59,69
0124E:  MOVLW  3F
01250:  MOVWF  x6A
01252:  MOVFF  5A,6B
01256:  MOVFF  5B,6C
0125A:  CALL   0028
....................    }
....................   
....................    if(inputcd(DW)==0)
0125E:  MOVLW  7C
01260:  MOVWF  x67
01262:  MOVLW  0D
01264:  MOVWF  x66
01266:  CALL   0206
0126A:  MOVF   01,F
0126C:  BNZ   1270
....................     {
....................       ledRun = 0;
0126E:  BCF    0E.2
....................     }
....................   if(ledRun == 1)
01270:  BTFSS  0E.2
01272:  BRA    12C2
....................   {
....................    bienDem = get_rtcc();
01274:  MOVF   FD6,W
01276:  MOVWF  56
....................    
....................    trangThaiLed++;
01278:  INCF   55,F
....................    
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0127A:  CLRF   03
0127C:  MOVF   55,W
0127E:  MOVWF  00
01280:  BTFSC  FE8.7
01282:  DECF   03,F
01284:  CALL   0004
01288:  MOVWF  59
0128A:  CLRF   03
0128C:  MOVF   58,W
0128E:  CALL   0004
01292:  MOVWF  5A
01294:  CLRF   03
01296:  MOVF   57,W
01298:  CALL   0004
0129C:  MOVWF  5B
0129E:  MOVFF  59,69
012A2:  MOVLW  3F
012A4:  MOVWF  x6A
012A6:  MOVFF  5A,6B
012AA:  MOVFF  5B,6C
012AE:  CALL   0028
....................    b302_16led_chop_tat(1000);
012B2:  CLRF   5C
012B4:  CLRF   5B
012B6:  MOVLW  03
012B8:  MOVWF  5A
012BA:  MOVLW  E8
012BC:  MOVWF  59
012BE:  GOTO   0452
....................   }
....................     if(inputcd(DW)==0)
012C2:  MOVLW  7C
012C4:  MOVWF  x67
012C6:  MOVLW  0D
012C8:  MOVWF  x66
012CA:  CALL   0206
012CE:  MOVF   01,F
012D0:  BNZ   12D4
....................     {
....................       ledRun = 0;
012D2:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
012D4:  BTFSS  0E.2
012D6:  BRA    1328
....................    {
....................     bienDem = get_rtcc();
012D8:  MOVF   FD6,W
012DA:  MOVWF  56
....................    trangThaiLed++;
012DC:  INCF   55,F
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
012DE:  CLRF   03
012E0:  MOVF   55,W
012E2:  MOVWF  00
012E4:  BTFSC  FE8.7
012E6:  DECF   03,F
012E8:  CALL   0004
012EC:  MOVWF  59
012EE:  CLRF   03
012F0:  MOVF   58,W
012F2:  CALL   0004
012F6:  MOVWF  5A
012F8:  CLRF   03
012FA:  MOVF   57,W
012FC:  CALL   0004
01300:  MOVWF  5B
01302:  MOVFF  59,69
01306:  MOVLW  3F
01308:  MOVWF  x6A
0130A:  MOVFF  5A,6B
0130E:  MOVFF  5B,6C
01312:  CALL   0028
....................    b303_32led_chop_tat(1000);
01316:  CLRF   5C
01318:  CLRF   5B
0131A:  MOVLW  03
0131C:  MOVWF  5A
0131E:  MOVLW  E8
01320:  MOVWF  59
01322:  GOTO   0592
....................    trangThaiLed++;
01326:  INCF   55,F
....................    }
....................     if(inputcd(DW)==0)
01328:  MOVLW  7C
0132A:  MOVWF  x67
0132C:  MOVLW  0D
0132E:  MOVWF  x66
01330:  CALL   0206
01334:  MOVF   01,F
01336:  BNZ   133A
....................     {
....................       ledRun = 0;
01338:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
0133A:  BTFSS  0E.2
0133C:  BRA    138A
....................    {
....................     bienDem = get_rtcc();
0133E:  MOVF   FD6,W
01340:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01342:  CLRF   03
01344:  MOVF   55,W
01346:  MOVWF  00
01348:  BTFSC  FE8.7
0134A:  DECF   03,F
0134C:  CALL   0004
01350:  MOVWF  59
01352:  CLRF   03
01354:  MOVF   58,W
01356:  CALL   0004
0135A:  MOVWF  5A
0135C:  CLRF   03
0135E:  MOVF   57,W
01360:  CALL   0004
01364:  MOVWF  5B
01366:  MOVFF  59,69
0136A:  MOVLW  3F
0136C:  MOVWF  x6A
0136E:  MOVFF  5A,6B
01372:  MOVFF  5B,6C
01376:  CALL   0028
....................    b304_16led_phai_std_pst(100);
0137A:  CLRF   5C
0137C:  CLRF   5B
0137E:  CLRF   5A
01380:  MOVLW  64
01382:  MOVWF  59
01384:  GOTO   0710
....................    trangThaiLed++;
01388:  INCF   55,F
....................    }
....................     if(inputcd(DW)==0)
0138A:  MOVLW  7C
0138C:  MOVWF  x67
0138E:  MOVLW  0D
01390:  MOVWF  x66
01392:  CALL   0206
01396:  MOVF   01,F
01398:  BNZ   139C
....................     {
....................       ledRun = 0;
0139A:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
0139C:  BTFSS  0E.2
0139E:  BRA    13EC
....................    {
....................     bienDem = get_rtcc();
013A0:  MOVF   FD6,W
013A2:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
013A4:  CLRF   03
013A6:  MOVF   55,W
013A8:  MOVWF  00
013AA:  BTFSC  FE8.7
013AC:  DECF   03,F
013AE:  CALL   0004
013B2:  MOVWF  59
013B4:  CLRF   03
013B6:  MOVF   58,W
013B8:  CALL   0004
013BC:  MOVWF  5A
013BE:  CLRF   03
013C0:  MOVF   57,W
013C2:  CALL   0004
013C6:  MOVWF  5B
013C8:  MOVFF  59,69
013CC:  MOVLW  3F
013CE:  MOVWF  x6A
013D0:  MOVFF  5A,6B
013D4:  MOVFF  5B,6C
013D8:  CALL   0028
....................    b305_16led_trai_std_tsp(100);
013DC:  CLRF   5C
013DE:  CLRF   5B
013E0:  CLRF   5A
013E2:  MOVLW  64
013E4:  MOVWF  59
013E6:  GOTO   08BE
....................    trangThaiLed++;
013EA:  INCF   55,F
....................    }
....................     if(inputcd(DW)==0)
013EC:  MOVLW  7C
013EE:  MOVWF  x67
013F0:  MOVLW  0D
013F2:  MOVWF  x66
013F4:  CALL   0206
013F8:  MOVF   01,F
013FA:  BNZ   13FE
....................     {
....................       ledRun = 0;
013FC:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
013FE:  BTFSS  0E.2
01400:  BRA    144E
....................    {
....................     bienDem = get_rtcc();
01402:  MOVF   FD6,W
01404:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01406:  CLRF   03
01408:  MOVF   55,W
0140A:  MOVWF  00
0140C:  BTFSC  FE8.7
0140E:  DECF   03,F
01410:  CALL   0004
01414:  MOVWF  59
01416:  CLRF   03
01418:  MOVF   58,W
0141A:  CALL   0004
0141E:  MOVWF  5A
01420:  CLRF   03
01422:  MOVF   57,W
01424:  CALL   0004
01428:  MOVWF  5B
0142A:  MOVFF  59,69
0142E:  MOVLW  3F
01430:  MOVWF  x6A
01432:  MOVFF  5A,6B
01436:  MOVFF  5B,6C
0143A:  CALL   0028
....................    b306_32led_std_tnv(100);
0143E:  CLRF   5C
01440:  CLRF   5B
01442:  CLRF   5A
01444:  MOVLW  64
01446:  MOVWF  59
01448:  GOTO   0A3C
....................    trangThaiLed++;
0144C:  INCF   55,F
....................    }
....................     if(inputcd(DW)==0)
0144E:  MOVLW  7C
01450:  MOVWF  x67
01452:  MOVLW  0D
01454:  MOVWF  x66
01456:  CALL   0206
0145A:  MOVF   01,F
0145C:  BNZ   1460
....................     {
....................       ledRun = 0;
0145E:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
01460:  BTFSS  0E.2
01462:  BRA    14B0
....................    {
....................     bienDem = get_rtcc();
01464:  MOVF   FD6,W
01466:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01468:  CLRF   03
0146A:  MOVF   55,W
0146C:  MOVWF  00
0146E:  BTFSC  FE8.7
01470:  DECF   03,F
01472:  CALL   0004
01476:  MOVWF  59
01478:  CLRF   03
0147A:  MOVF   58,W
0147C:  CALL   0004
01480:  MOVWF  5A
01482:  CLRF   03
01484:  MOVF   57,W
01486:  CALL   0004
0148A:  MOVWF  5B
0148C:  MOVFF  59,69
01490:  MOVLW  3F
01492:  MOVWF  x6A
01494:  MOVFF  5A,6B
01498:  MOVFF  5B,6C
0149C:  CALL   0028
....................    b307_32led_std_ttr(100);
014A0:  CLRF   5C
014A2:  CLRF   5B
014A4:  CLRF   5A
014A6:  MOVLW  64
014A8:  MOVWF  59
014AA:  GOTO   0C50
....................    trangThaiLed++;
014AE:  INCF   55,F
....................    }
....................     if(inputcd(DW)==0)
014B0:  MOVLW  7C
014B2:  MOVWF  x67
014B4:  MOVLW  0D
014B6:  MOVWF  x66
014B8:  CALL   0206
014BC:  MOVF   01,F
014BE:  BNZ   14C2
....................     {
....................       ledRun = 0;
014C0:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
014C2:  BTFSS  0E.2
014C4:  BRA    1510
....................    {
....................     bienDem = get_rtcc();
014C6:  MOVF   FD6,W
014C8:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
014CA:  CLRF   03
014CC:  MOVF   55,W
014CE:  MOVWF  00
014D0:  BTFSC  FE8.7
014D2:  DECF   03,F
014D4:  CALL   0004
014D8:  MOVWF  59
014DA:  CLRF   03
014DC:  MOVF   58,W
014DE:  CALL   0004
014E2:  MOVWF  5A
014E4:  CLRF   03
014E6:  MOVF   57,W
014E8:  CALL   0004
014EC:  MOVWF  5B
014EE:  MOVFF  59,69
014F2:  MOVLW  3F
014F4:  MOVWF  x6A
014F6:  MOVFF  5A,6B
014FA:  MOVFF  5B,6C
014FE:  CALL   0028
....................    b308_32led_std_pst(100);
01502:  CLRF   5C
01504:  CLRF   5B
01506:  CLRF   5A
01508:  MOVLW  64
0150A:  MOVWF  59
0150C:  BRA    0E10
....................    trangThaiLed++;
0150E:  INCF   55,F
....................    }
....................     if(inputcd(DW)==0)
01510:  MOVLW  7C
01512:  MOVWF  x67
01514:  MOVLW  0D
01516:  MOVWF  x66
01518:  CALL   0206
0151C:  MOVF   01,F
0151E:  BNZ   1522
....................     {
....................       ledRun = 0;
01520:  BCF    0E.2
....................     }
....................    if(ledRun == 1)
01522:  BTFSS  0E.2
01524:  BRA    1570
....................    {
....................     bienDem = get_rtcc();
01526:  MOVF   FD6,W
01528:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
0152A:  CLRF   03
0152C:  MOVF   55,W
0152E:  MOVWF  00
01530:  BTFSC  FE8.7
01532:  DECF   03,F
01534:  CALL   0004
01538:  MOVWF  59
0153A:  CLRF   03
0153C:  MOVF   58,W
0153E:  CALL   0004
01542:  MOVWF  5A
01544:  CLRF   03
01546:  MOVF   57,W
01548:  CALL   0004
0154C:  MOVWF  5B
0154E:  MOVFF  59,69
01552:  MOVLW  3F
01554:  MOVWF  x6A
01556:  MOVFF  5A,6B
0155A:  MOVFF  5B,6C
0155E:  CALL   0028
....................    b309_32led_std_tsp(100);
01562:  CLRF   5C
01564:  CLRF   5B
01566:  CLRF   5A
01568:  MOVLW  64
0156A:  MOVWF  59
0156C:  BRA    0FBC
....................    trangThaiLed++;
0156E:  INCF   55,F
....................    }
....................    
....................     bienDem = get_rtcc();
01570:  MOVF   FD6,W
01572:  MOVWF  56
....................    xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01574:  CLRF   03
01576:  MOVF   55,W
01578:  MOVWF  00
0157A:  BTFSC  FE8.7
0157C:  DECF   03,F
0157E:  CALL   0004
01582:  MOVWF  59
01584:  CLRF   03
01586:  MOVF   58,W
01588:  CALL   0004
0158C:  MOVWF  5A
0158E:  CLRF   03
01590:  MOVF   57,W
01592:  CALL   0004
01596:  MOVWF  5B
01598:  MOVFF  59,69
0159C:  MOVLW  3F
0159E:  MOVWF  x6A
015A0:  MOVFF  5A,6B
015A4:  MOVFF  5B,6C
015A8:  CALL   0028
....................    trangThaiLed = 0;
015AC:  CLRF   55
015AE:  GOTO   16C2 (RETURN)
.................... }
.................... void main()
015B2:  CLRF   FF8
015B4:  BCF    FD0.7
015B6:  CLRF   12
015B8:  CLRF   11
015BA:  CLRF   10
015BC:  CLRF   0F
015BE:  CLRF   16
015C0:  CLRF   15
015C2:  CLRF   14
015C4:  MOVLW  01
015C6:  MOVWF  13
015C8:  MOVLW  80
015CA:  MOVWF  1A
015CC:  CLRF   19
015CE:  CLRF   18
015D0:  CLRF   17
015D2:  CLRF   1E
015D4:  CLRF   1D
015D6:  CLRF   1C
015D8:  CLRF   1B
015DA:  MOVWF  22
015DC:  CLRF   21
015DE:  CLRF   24
015E0:  MOVLW  01
015E2:  MOVWF  23
015E4:  CLRF   26
015E6:  CLRF   25
015E8:  MOVLW  80
015EA:  MOVWF  2A
015EC:  CLRF   29
015EE:  CLRF   2C
015F0:  MOVLW  01
015F2:  MOVWF  2B
015F4:  CLRF   2E
015F6:  CLRF   2D
015F8:  CLRF   30
015FA:  CLRF   2F
015FC:  CLRF   31
015FE:  MOVLW  20
01600:  MOVWF  32
01602:  CLRF   33
01604:  MOVLW  01
01606:  MOVWF  34
01608:  MOVLW  10
0160A:  MOVWF  35
0160C:  CLRF   36
0160E:  CLRF   3A
01610:  CLRF   39
01612:  CLRF   38
01614:  MOVLW  01
01616:  MOVWF  37
01618:  CLRF   3E
0161A:  CLRF   3D
0161C:  CLRF   3C
0161E:  MOVWF  3B
01620:  SETF   42
01622:  SETF   41
01624:  SETF   40
01626:  MOVLW  FE
01628:  MOVWF  3F
0162A:  MOVLW  80
0162C:  MOVWF  46
0162E:  CLRF   45
01630:  CLRF   44
01632:  CLRF   43
01634:  MOVWF  4A
01636:  CLRF   49
01638:  CLRF   48
0163A:  CLRF   47
0163C:  MOVLW  7F
0163E:  MOVWF  4E
01640:  SETF   4D
01642:  SETF   4C
01644:  SETF   4B
01646:  MOVLW  01
01648:  MOVWF  4F
0164A:  MOVWF  50
0164C:  BCF    F63.5
0164E:  MOVLW  00
01650:  MOVWF  F64
01652:  MOVLW  20
01654:  MOVWF  F63
01656:  BCF    F95.4
01658:  BSF    F95.5
0165A:  BCF    F95.6
0165C:  CLRF   54
0165E:  CLRF   53
01660:  CLRF   52
01662:  CLRF   51
01664:  CLRF   55
01666:  BCF    0E.2
01668:  MOVF   FC1,W
0166A:  ANDLW  C0
0166C:  IORLW  0F
0166E:  MOVWF  FC1
01670:  MOVLW  07
01672:  MOVWF  FB4
01674:  SETF   04
01676:  SETF   05
01678:  SETF   06
0167A:  SETF   07
0167C:  SETF   08
0167E:  SETF   09
01680:  SETF   0A
01682:  SETF   0B
01684:  SETF   0C
01686:  SETF   0D
01688:  BCF    0E.0
0168A:  BCF    0E.1
.................... {
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
0168C:  MOVF   FC1,W
0168E:  ANDLW  C0
01690:  IORLW  0F
01692:  MOVWF  FC1
....................    set_up_port_ic_chot(); 
01694:  GOTO   014A
.................... 
....................    hardwareInit();
01698:  GOTO   0186
.................... 
....................    while(TRUE)
....................    {
....................    
....................      if(inputcd(DW)==0)
0169C:  MOVLW  7C
0169E:  MOVWF  x67
016A0:  MOVLW  0D
016A2:  MOVWF  x66
016A4:  CALL   0206
016A8:  MOVF   01,F
016AA:  BNZ   16AE
....................     {
....................       ledRun = 0;
016AC:  BCF    0E.2
....................     }
....................     if(inputcd(UP)==0)
016AE:  MOVLW  7C
016B0:  MOVWF  x67
016B2:  MOVLW  0C
016B4:  MOVWF  x66
016B6:  CALL   0206
016BA:  MOVF   01,F
016BC:  BNZ   16C0
....................     {
....................       ledRun = 1;
016BE:  BSF    0E.2
....................     }
....................     led();
016C0:  BRA    117E
....................     bienDem = get_rtcc();
016C2:  MOVF   FD6,W
016C4:  MOVWF  56
....................    if(bienDem>24)
016C6:  MOVF   56,W
016C8:  SUBLW  18
016CA:  BC    16D4
....................    {
....................      bienDem = 0; 
016CC:  CLRF   56
....................      set_rtcc(0);
016CE:  CLRF   FD7
016D0:  CLRF   FD6
016D2:  NOP   
....................    }
....................       hangDonVi = bienDem%10;
016D4:  MOVFF  56,66
016D8:  MOVLW  0A
016DA:  MOVWF  x67
016DC:  CALL   02D4
016E0:  MOVFF  00,57
....................       hangChuc = bienDem / 10;
016E4:  MOVFF  56,66
016E8:  MOVLW  0A
016EA:  MOVWF  x67
016EC:  CALL   02D4
016F0:  MOVFF  01,58
....................    
....................       if (inputcd(INV) == 0)
016F4:  MOVLW  7C
016F6:  MOVWF  x67
016F8:  MOVLW  0E
016FA:  MOVWF  x66
016FC:  CALL   0206
01700:  MOVF   01,F
01702:  BNZ   1714
....................       {
....................          trangThaiDem = ~trangThaiDem;
01704:  BTG    0E.3
....................          if(trangThaiDem)
01706:  BTFSS  0E.3
01708:  BRA    170E
....................          {
....................             setup_timer_0(RTCC_OFF);
0170A:  CLRF   FD5
....................          }else
0170C:  BRA    1714
....................          {
....................             setup_counters(RTCC_EXT_L_TO_H,RTCC_DIV_1);
0170E:  BCF    FD1.0
01710:  MOVLW  A8
01712:  MOVWF  FD5
....................          }
....................         
....................       }
....................       
.................... 
.................... 
....................       xuat_4led_7doan_4so(  MA7DOAN[trangThaiLed],0b0111111,MA7DOAN[hangChuc],MA7DOAN[hangDonVi]);
01714:  CLRF   03
01716:  MOVF   55,W
01718:  MOVWF  00
0171A:  BTFSC  FE8.7
0171C:  DECF   03,F
0171E:  CALL   0004
01722:  MOVWF  59
01724:  CLRF   03
01726:  MOVF   58,W
01728:  CALL   0004
0172C:  MOVWF  5A
0172E:  CLRF   03
01730:  MOVF   57,W
01732:  CALL   0004
01736:  MOVWF  5B
01738:  MOVFF  59,69
0173C:  MOVLW  3F
0173E:  MOVWF  x6A
01740:  MOVFF  5A,6B
01744:  MOVFF  5B,6C
01748:  CALL   0028
0174C:  BRA    169C
....................       
....................       
....................   
....................        
....................    }
....................   
.................... }
.................... 
0174E:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 85F3   CCP2C1 LPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
